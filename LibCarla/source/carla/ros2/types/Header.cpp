// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
// 版权声明，表明这段代码的版权归属于 Proyectos y Sistemas de Mantenimiento SL (eProsima) 公司，受相应版权法律保护。
//
// Licensed under the Apache License, Version 2.0 (the "License");
// 说明代码基于 Apache 2.0 许可证授权使用，意味着使用者需要遵循该许可证的相关条款来使用此代码。
// you may not use this file except in compliance with the License.
// 强调只有在符合许可证要求的情况下才能使用本文件（即当前代码文件）。
// You may obtain a copy of the License at
// 告知可以通过指定的网址获取该许可证的副本，方便使用者查看具体的许可条款内容。
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// 指出除非有相关法律要求或者书面约定，依据该许可证分发的软件是以“现状”提供的，即不提供额外的保证或担保等。
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// 明确表示不提供任何形式（无论是明示还是暗示）的保证或条件，例如对代码的适用性、无错误性等方面不做承诺。
// See the License for the specific language governing permissions and
// limitations under the License.
// 提示需要查看许可证内容来了解关于权限（比如使用、修改、分发等权限）以及限制方面的具体规定。

/*!
 * @file Header.cpp
 * This source file contains the definition of the described types in the IDL file.
 * 此源文件（Header.cpp）包含了在接口定义语言（IDL）文件中所描述类型的具体定义实现。
 * 意味着它将 IDL 中抽象定义的类型在 C++ 语言环境下进行了具体的功能实现，使其能够在 C++ 程序中被实例化和使用，通常用于跨语言通信等场景下对消息结构的定义。
 *
 * This file was generated by the tool gen.
 * 表明这个文件是通过名为“gen”的工具自动生成的，一般自动生成的代码遵循特定的代码生成规则和模板，
 * 目的是保证与对应的 IDL 定义以及整个项目的代码规范相契合，减少手动编写代码可能出现的错误，提高开发效率。
 */

// 以下这段#ifdef _WIN32 到 #endif _WIN32 的代码块是针对 Windows 操作系统平台（通过_WIN32 宏来判断是否为 Windows 环境）的特定处理。
// 在 Visual Studio 编译环境下，有时候会出现链接器警告 LNK4221，为了避免这个警告，通过定义一个匿名的 namespace 并在其中声明一个未使用的字符变量 dummy，
// 利用了编译器对于未使用变量在匿名 namespace 内处理的一些特性来达到消除该警告的目的。这属于一种针对特定编译器和平台相关问题的常见解决技巧，对程序实际要实现的功能逻辑本身并没有直接的影响。
#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

// 包含名为“Header.h”的头文件，推测这个头文件中包含了 std_msgs::msg::Header 类的前置声明、结构体定义、枚举定义或者其他相关的类型信息，
// 是当前实现文件（Header.cpp）能够正确识别和使用 Header 类相关内容的基础，使得编译器在编译当前文件时知晓类的结构、成员等详细信息，确保代码编译过程中类型检查等操作能够顺利进行。
#include "Header.h"
// 包含 FastCDR 库中的 Cdr 类相关头文件，FastCDR 库常用于数据的序列化和反序列化操作，Cdr 类是该库中负责具体读写数据操作的核心类之一，
// 它提供了一套方便的接口用于将程序中的数据对象转换为适合存储（如写入文件、发送到网络等）或传输的格式，以及从相应格式还原为程序中可操作的数据对象，
// 在实现消息传递、数据持久化等功能时经常会用到这类序列化和反序列化机制。
#include <fastcdr/Cdr.h>

// 引入 FastCDR 库中异常相关的头文件，该头文件定义了在使用 FastCDR 库进行各种操作（如序列化、反序列化等）时可能出现的异常类型，例如参数错误（BadParamException）等情况对应的异常类，
// 在当前代码中引入这个头文件后，后续代码就可以捕获并按照特定的逻辑处理这些异常，从而保证程序在遇到意外情况时能够以合理的方式进行应对，增强程序的健壮性。
#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

// 包含 C++ 标准库中的 <utility> 头文件，这个头文件提供了一些实用的工具和功能，比如 std::move 函数等，
// std::move 函数在实现移动语义相关的代码（像移动构造函数、移动赋值运算符等）时起着关键作用，它可以将对象的资源所有权进行转移，避免不必要的深拷贝开销，有助于提高程序运行效率，尤其是在处理包含大量数据的对象时优势更为明显。
#include <utility>

// 定义一个宏，表示 builtin_interfaces::msg::Time 类型在最大 CDR 序列化时占用的字节大小为 8 字节（ULL 表示无符号长整型字面量后缀，用于明确数据类型的长度和表示范围），
// 这个宏定义的值可能在后续涉及到数据序列化大小计算、内存分配、缓冲区规划等相关操作中被引用，通过提前定义好这个固定大小值，可以方便且准确地判断该类型序列化后的空间占用情况，便于进行资源管理和优化。
#define builtin_interfaces_msg_Time_max_cdr_typesize 8ULL;
// 定义 std_msgs::msg::Header 类型在最大 CDR 序列化时占用的字节大小为 268 字节，同样用于在数据序列化相关的逻辑中作为参考依据，
// 比如在判断是否超出缓冲区大小限制、预估整体序列化后的数据长度以便合理分配内存等场景下，依据这个预定义的常量值来进行相应的操作决策，确保序列化过程的顺利进行以及数据的完整性和正确性。
#define std_msgs_msg_Header_max_cdr_typesize 268ULL;
// 定义 builtin_interfaces::msg::Time 类型在最大 CDR 键序列化时占用的字节大小为 0 字节，意味着在将该类型的数据作为键进行序列化时，按照当前的设计和实现，它不需要额外的空间来存储键相关的信息，
// 不过具体的序列化行为和空间占用情况还取决于具体的序列化框架以及使用场景对于键序列化的详细要求和实现方式，这里只是一种预先定义的特性描述。
#define builtin_interfaces_msg_Time_max_key_cdr_typesize 0ULL;
// 定义 std_msgs::msg::Header 类型在最大 CDR 键序列化时占用的字节大小为 0 字节，类似地说明了该类型在键序列化方面的空间特性，即按照当前设定，它在作为键进行序列化操作时不会占用实际的序列化空间，
// 这可能是因为其本身的数据结构或业务逻辑决定了它不适合或者不需要作为键来进行序列化，具体情况需结合整个项目的功能需求来综合判断。
#define std_msgs_msg_Header_max_key_cdr_typesize 0ULL;

// std_msgs::msg::Header 类的默认构造函数定义，
// 其主要作用是创建一个 std_msgs::msg::Header 类的对象实例，并对对象的部分成员变量进行初始化，设置对象的初始状态。
// 在这个构造函数中，将成员变量 m_frame_id 初始化为空字符串，以此明确该成员变量的初始值，方便后续根据实际需求进行修改和使用。
// 而对于成员变量 m_stamp 没有进行显式的初始化操作，通常是依赖其自身所属类型（大概率是一个自定义的类类型且有默认构造函数）的默认构造行为来完成初始化，
// 不同的类型在默认构造时会按照其自身内部定义的规则来设置初始值，例如内置基本类型（如 int 类型默认初始化为 0，指针类型默认初始化为 nullptr 等），类类型则会调用自身的默认构造函数来进行初始化操作。
std_msgs::msg::Header::Header()
{
    m_frame_id ="";
}

// std_msgs::msg::Header 类的析构函数定义，
// 析构函数在类的对象生命周期结束、即将被销毁时会自动被调用，其主要目的是释放对象在生命周期内所占用的各种资源，例如动态分配的内存、打开的文件句柄、网络连接资源等，确保系统资源的正确回收和合理利用。
// 在此处，析构函数的函数体为空，说明该类对象在销毁时不需要进行额外的特定资源释放操作，
// 成员变量相关的资源管理（例如如果成员变量本身是指针且指向动态分配内存，那么释放这块内存的操作应该在其所属类型的析构函数中进行处理）通常由它们各自所属类型的析构函数负责，遵循了 C++ 中对象资源管理的基本规则。
std_msgs::msg::Header::~Header()
{
}

// std_msgs::msg::Header 类的拷贝构造函数定义，
// 它的功能是基于已存在的一个 Header 类对象（由参数 x 表示）来创建一个新的 Header 类对象，实现对象的复制操作，使得新创建的对象与原对象在内容上保持一致。
// 具体的复制逻辑是将传入对象 x 的成员变量 m_stamp 和 m_frame_id 的值分别拷贝到新创建的对象中，
// 如果成员变量是简单的数据类型（如 int、float、char 等基本内置类型），则直接进行值拷贝，也就是将原对象对应成员变量的值复制一份给新对象的相应成员变量；
// 如果成员变量是类类型，那么会调用该类类型对应的拷贝构造函数来进行深层次的拷贝（即深拷贝），确保新对象和原对象在逻辑上是完全独立的两个副本，对其中一个对象的修改不会影响到另一个对象，保证了数据的独立性和安全性。
std_msgs::msg::Header::Header(
        const Header& x)
{
    m_stamp = x.m_stamp;
    m_frame_id = x.m_frame_id;
}

// std_msgs::msg::Header 类的移动构造函数定义，
// 接受一个右值引用类型的 Header 类对象 x 作为参数，右值引用（以 && 表示）常用于标识临时对象或者即将被销毁的对象，
// 通过 std::move 操作，可以将 x 对象中的成员变量 m_stamp 和 m_frame_id 资源“移动”（也就是转移所有权）到新创建的对象中，
// 这种移动语义的操作常用于避免不必要的深拷贝开销，特别是当对象内部包含大量数据（如动态分配的内存、复杂的容器等）时，移动操作相比于拷贝操作在效率上会有显著提升，
// 并且函数标记为 noexcept 表示此函数不会抛出异常，这对于一些依赖移动语义的优化以及与 C++ 标准库其他部分协同工作时具有重要意义，例如在某些容器重新分配内存等场景下，要求移动构造函数不能抛出异常以保证操作的原子性和正确性。
std_msgs::msg::Header::Header(
        Header&& x) noexcept
{
    m_stamp = std::move(x.m_stamp);
    m_frame_id = std::move(x.m_frame_id);
}

// std_msgs::msg::Header 类的拷贝赋值运算符重载函数定义，
// 用于将一个 const 引用的 Header 类对象 x 的成员变量值赋值给当前的 Header 类对象，实现对象之间的值传递以及更新当前对象状态的功能，使得当前对象的内容与传入对象 x 保持一致。
// 具体操作是先将传入对象 x 的 m_stamp 和 m_frame_id 成员变量的值分别赋给当前对象对应的成员变量，然后返回当前对象的引用（通过 *this 表示），
// 这样就支持了连续赋值操作（例如像 a = b = c 这种语法形式在 C++ 中是合法的，要求赋值运算符返回左值引用，以便可以继续进行后续的赋值操作），提高了代码编写的灵活性和简洁性。
std_msgs::msg::Header& std_msgs::msg::Header::operator =(
        const Header& x)
{
    m_stamp = x.m_stamp;
    m_frame_id = x.m_frame_id;

    return *this;
}

// std_msgs::msg::Header 类的移动赋值运算符重载函数定义，
// 接受一个右值引用的 Header 类对象 x 作为参数，通过 std::move 操作将 x 对象的成员变量 m_stamp 和 m_frame_id 资源转移到当前对象中，
// 同样标记为 noexcept 表示不会抛出异常，更新当前对象状态后返回当前对象的引用（通过 *this 表示），便于连续赋值等操作，
// 其原理和移动构造函数类似，都是利用移动语义来高效地处理对象赋值情况，避免不必要的拷贝开销，尤其适用于将临时对象赋值给其他对象的场景，能够优化程序性能，减少不必要的资源消耗。
std_msgs::msg::Header& std_msgs::msg::Header::operator =(
        Header&& x) noexcept
{
    m_stamp = std::move(x.m_stamp);
    m_frame_id = std::move(x.m_frame_id);

    return *this;
}

// 重载了相等比较运算符（==），用于比较两个 Header 类对象是否相等。
// 比较的逻辑是判断两个对象的成员变量 m_stamp 和 m_frame_id 是否分别相等，只有当这两个成员变量都相等时，才返回 true，表示两个对象在逻辑上是完全相等的；
// 否则返回 false，表示两个对象不相等。通过重载这个运算符，方便了在程序中直接使用 == 来比较 Header 类对象，符合人们通常的编程习惯和逻辑判断需求，使得代码更加直观和易于理解。
bool std_msgs::msg::Header::operator ==(
        const Header& x) const
{
    return (m_stamp == x.m_stamp && m_frame_id == x.m_frame_id);
}

// 重载了不等比较运算符（!=），通过调用上面定义的相等比较运算符（==）取反来实现逻辑，
// 即如果两个对象通过相等比较运算符判断为不相等，那么就返回 true，表示这两个对象在逻辑上是不一样的；
// 如果相等比较运算符返回 true（即两个对象相等），则此处返回 false，表示两个对象并非不等的关系，这种通过取反来实现不等比较运算符的方式符合 C++ 中运算符重载的常规做法，保持了逻辑的一致性和简洁性。
bool std_msgs::msg::Header::operator!=(
        const Header& x) const
{
    return!(*this == x);
}

// 获取 std_msgs::msg::Header 类型对象在最大 CDR 序列化时的大小（以字节为单位）的函数定义，
// 参数 current_alignment 当前在代码中并没有实际参与具体的计算（通过 static_cast<void> 进行了类型转换，将其转换为空类型以避免编译器发出未使用参数的警告），
// 函数直接返回了预定义的 std_msgs_msg_Header_max_cdr_typesize 常量值，这个常量代表了该类型对象在进行最大程度序列化时所需要占用的字节大小，
// 可以用于在内存分配、缓冲区大小判断等相关操作中作为参考依据，确保有足够的空间来存储序列化后的数据，避免出现缓冲区溢出等问题，保证数据处理的稳定性和正确性。
size_t std_msgs::msg::Header::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return std_msgs_msg_Header_max_cdr_typesize;
}

// 获取给定 std_msgs::msg::Header 类型对象 data 的 CDR 序列化大小（以字节为单位）的函数定义，
// 函数接受要序列化的对象 data 以及当前的对齐字节数 current_alignment 作为参数。
// 首先记录初始的对齐字节数 initial_alignment，以便后续准确计算序列化后总的字节数变化量。
// 然后通过调用 builtin_interfaces::msg::Time 类型的相关序列化函数来计算成员变量 m_stamp 序列化后的对齐字节数变化，
// 接着计算成员变量 m_frame_id 序列化后的对齐字节数变化（包含了字符串长度等相关计算以及按照 4 字节对齐的处理，例如加上 4 字节对齐的额外空间、字符串实际长度以及字符串结尾的空字符占用的 1 字节空间等），
// 最后返回总的字节数变化量（即当前对齐字节数减去初始对齐字节数），这个返回值就是对象 data 序列化后的实际大小，可用于准确控制数据序列化的过程以及相关的内存操作，比如合理分配缓冲区空间等。
size_t std_msgs::msg::Header::getCdrSerializedSize(
        const std_msgs::msg::Header& data,
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    current_alignment += builtin_interfaces::msg::Time::getCdrSerializedSize(data.stamp(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.frame_id().size() + 1;

    return current_alignment - initial_alignment;
}

// 用于将 std_msgs::msg::Header 类对象进行序列化的函数定义，通过 FastCDR 的 Cdr 对象 scdr 将对象的状态输出到某种存储介质（比如网络流、文件等），实现数据的序列化过程，将对象转换为可以存储或传输的格式。
// 具体的操作是先将成员变量m_stamp序列化到scdr中，这里利用了Cdr类提供的序列化操作符<<来实现，按照其内置的序列化规则将时间相关的数据转换为相应格式保存到scdr中。
// 然后将成员变量m_frame_id（以C风格字符串形式，通过调用c_str()方法获取字符串的字符数组表示）序列化到scdr中，同样遵循Cdr类对于字符串类型的序列化方式进行处理，
// 如此按照特定的序列化格式和顺序将对象的各个成员变量转换为可存储或传输的数据形式，以便后续在需要的地方可以进行反序列化还原对象状态，实现数据的持久化或者在网络间传递等功能。
void std_msgs::msg::Header::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_stamp;
    scdr << m_frame_id.c_str();
}

// 用于将从某种存储介质（比如网络流、文件等）读取的数据反序列化到std_msgs::msg::Header类对象中的函数定义，
// 通过FastCDR的Cdr对象dcdr来读取数据，并按照与serialize函数相反的顺序和逻辑将数据还原到对象的成员变量中，以此恢复对象的状态，使得对象从序列化后的形式重新变回程序中可操作的内存对象形式。
// 具体操作是先将读取的数据反序列化到成员变量m_stamp中，利用Cdr类的反序列化操作符>>按照相应规则将存储的时间数据解析并赋值给m_stamp，
// 再将数据反序列化到成员变量m_frame_id中，同样依据其反序列化规则将存储的字符串数据还原为std::string类型赋值给m_frame_id，从而完整地恢复对象的原始状态。
void std_msgs::msg::Header::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_stamp;
    dcdr >> m_frame_id;
}

/*!
 * @brief This function copies the value in member stamp
 * @param _stamp New value to be copied in member stamp
 * 此函数用于将传入的参数_stamp的值拷贝到成员变量m_stamp中，实现对成员变量stamp的赋值操作，是一种常规的拷贝赋值方式，
 * 常用于在程序运行过程中根据外部传入的新时间值来更新对象内部所记录的时间信息，保证对象的时间状态能准确反映实际情况，例如从网络接收新的时间戳数据后用来更新当前Header对象的时间部分。
 */
void std_msgs::msg::Header::stamp(
        const builtin_interfaces::msg::Time& _stamp)
{
    m_stamp = _stamp;
}

/*!
 * @brief This function moves the value in member stamp
 * @param _stamp New value to be moved in member stamp
 * 这个函数用于将传入的参数_stamp的值通过移动语义移动到成员变量m_stamp中，
 * 适用于传入的参数是右值（比如临时对象，例如某个函数返回的临时的Time类型对象，且该对象后续不再需要使用）的情况，
 * 采用移动语义能够更高效地更新成员变量stamp的状态，避免不必要的拷贝开销，尤其是当Time类型对象内部包含较多数据或者复杂结构时，移动操作可显著提升程序性能，减少不必要的资源消耗。
 */
void std_msgs::msg::Header::stamp(
        builtin_interfaces::msg::Time&& _stamp)
{
    m_stamp = std::move(_stamp);
}

/*!
 * @brief This function returns a constant reference to member stamp
 * @return Constant reference to member stamp
 * 该函数返回成员变量m_stamp的常量引用，这意味着调用者可以通过这个返回值访问m_stamp的值，但不能对其进行修改，
 * 常用于在不希望对象内部状态被外部意外修改的场景下对外提供数据访问，比如在仅需要查看对象当前时间信息的函数中，通过返回常量引用确保外部代码不能误修改时间值，保障了数据的只读性和对象状态的稳定性。
 */
const builtin_interfaces::msg::Time& std_msgs::msg::Header::stamp() const
{
    return m_stamp;
}

/*!
 * @brief This function returns a reference to member stamp
 * @return Reference to member stamp
 * 此函数返回成员变量m_stamp的普通引用，调用者可以通过这个返回值访问和修改m_stamp的值，
 * 用于在需要对成员变量进行修改操作的场景下对外提供数据访问，例如在需要更新对象的时间信息的函数中，通过获取这个引用就可以直接对时间成员变量进行赋值等修改操作，方便灵活地控制对象的时间状态。
 */
builtin_interfaces::msg::Time& std_msgs::msg::Header::stamp()
{
    return m_stamp;
}

/*!
 * @brief This function copies the value in member frame_id
 * @param _frame_id New value to be copied in member frame_id
 * 下面这个函数用于将传入的参数_frame_id的值拷贝到成员变量m_frame_id中，实现对成员变量frame_id的赋值操作，
 * 这是一种常规的拷贝赋值方式，主要用于在程序运行过程中根据实际需求更新对象的这个成员变量状态，
 * 比如根据不同的业务场景、配置信息或者从外部数据源获取新的帧标识来改变该成员变量所代表的帧标识信息等情况时会调用此函数，确保对象的帧标识准确反映当前实际情况。
 */
void std_msgs::msg::Header::frame_id(
        const std::string& _frame_id)
{
    m_frame_id = _frame_id;
}

/*!
 * @brief This function moves the value in member frame_id
 * @param _frame_id New value to be moved in member frame_id
 * 此函数用于将传入的参数_frame_id的值通过移动语义移动到成员变量m_frame_id中，
 * 当传入的参数是右值（例如一个临时创建的字符串对象，且后续不再需要使用该临时对象时）的情况下，
 * 采用移动语义可以避免不必要的字符串拷贝操作，更高效地更新成员变量frame_id的状态，提升程序性能，减少内存等资源的消耗，尤其在处理大量字符串数据或者频繁更新帧标识的场景下优势明显。
 */
void std_msgs::msg::Header::frame_id(
        std::string&& _frame_id)
{
    m_frame_id = std::move(_frame_id);
}

/*!
 * @brief This function returns a constant reference to member frame_id
 * @return Constant reference to member frame_id
 * 该函数返回成员变量m_frame_id的常量引用，调用者通过这个返回值可以访问m_frame_id的值，但无法对其进行修改，
 * 这种方式常用于那些只需要获取该成员变量的值而不希望改变它的场景，例如在打印输出对象的帧标识信息、将帧标识信息传递给只读函数进行处理等操作中会使用，能保证数据的只读性和安全性，防止意外修改导致的错误。
 */
const std::string& std_msgs::msg::Header::frame_id() const
{
    return m_frame_id;
}

/*!
 * @brief This function returns a reference to member frame_id
 * @return Reference to member frame_id
 * 此函数返回成员变量m_frame_id的普通引用，调用者借助这个返回值不仅可以访问m_frame_id的值，还能够对其进行修改，
 * 在需要动态改变对象的帧标识信息的情况下就会用到，比如根据运行时的不同情况重新设置帧标识、根据用户输入更新帧标识等操作时，通过这个引用可以方便地进行赋值等修改行为，灵活地控制对象的相关属性。
 */
std::string& std_msgs::msg::Header::frame_id()
{
    return m_frame_id;
}

// 获取std_msgs::msg::Header类型对象在最大CDR键序列化时的大小（以字节为单位）的函数定义，
// 参数current_alignment在当前代码中并没有真正参与实际的计算逻辑（通过static_cast<void>进行类型转换来避免编译器提示未使用参数的警告），
// 函数直接返回了预定义的std_msgs_msg_Header_max_key_cdr_typesize常量值（这里为0字节），它代表了该类型对象在作为键进行最大程度序列化时所占用的字节大小，
// 从返回值来看该类型对象在当前设计下作为键序列化时不占用额外空间，不过这取决于具体的序列化框架和应用场景对键序列化的要求和定义，若后续需求变更可能需要重新评估和调整相关实现。
size_t std_msgs::msg::Header::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return std_msgs_msg_Header_max_key_cdr_typesize;
}

// 判断std_msgs::msg::Header类型对象是否定义了键的函数定义，当前函数直接返回false，表示该类型对象按照当前的设计和实现并没有定义键相关的内容，
// 意味着在使用涉及键操作的序列化、查找等相关功能时，该类型对象在这方面没有对应的有效数据或者行为，具体是否需要键相关功能取决于具体的业务逻辑和使用场景，
// 若后续业务需要基于键来进行诸如快速查找、索引等操作，则需要对该类型进行扩展以支持键的定义和相关序列化等处理。
bool std_msgs::msg::Header::isKeyDefined()
{
    return false;
}

// 用于将std_msgs::msg::Header类对象的键进行序列化的函数定义，
// 不过由于前面isKeyDefined函数返回false，表明该类型对象不存在实际的键序列化内容，
// 所以当前函数体中只是简单地将传入的FastCDR的Cdr对象scdr忽略（通过(void) scdr;语句），并没有进行实质性的序列化操作，
// 这符合其没有键定义情况下的逻辑处理，如果后续需要支持键序列化功能，那么此处的函数实现就需要根据具体的键定义和序列化要求进行相应的修改完善，比如确定键由哪些成员变量组成以及它们的序列化顺序和格式等。
void std_msgs::msg::Header::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}
