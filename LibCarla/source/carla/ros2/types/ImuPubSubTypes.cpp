// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file ImuPubSubTypes.cpp
 * This header file contains the implementation of the serialization functions.
 *
 * This file was generated by the tool fastcdrgen.
 */

// 引入FastCDR库中用于处理缓冲区相关操作的头文件
#include <fastcdr/FastBuffer.h>
// 引入FastCDR库中用于处理CDR（通用数据表示）序列化和反序列化操作的头文件
#include <fastcdr/Cdr.h>
// 引入自定义的ImuPubSubTypes相关头文件，可能包含了Imu类型等相关定义
#include "ImuPubSubTypes.h"

// 为eprosima::fastrtps::rtps::SerializedPayload_t类型定义一个别名SerializedPayload_t，方便后续代码书写和理解
using SerializedPayload_t = eprosima::fastrtps::rtps::SerializedPayload_t;
// 为eprosima::fastrtps::rtps::InstanceHandle_t类型定义一个别名InstanceHandle_t，方便后续代码书写和理解
using InstanceHandle_t = eprosima::fastrtps::rtps::InstanceHandle_t;

// sensor_msgs命名空间下的msg子命名空间，这里应该是存放与消息相关的类型和操作的地方
namespace sensor_msgs {
    namespace msg {

        // ImuPubSubType类的构造函数，用于初始化该类型相关的一些属性，主要是为序列化和反序列化做准备
        ImuPubSubType::ImuPubSubType()
        {
            // 设置类型的名称为 "sensor_msgs::msg::dds_::Imu_"，这是ROS 2中的IMU消息类型，该名称用于在序列化和反序列化过程中标识消息类型
            setName("sensor_msgs::msg::dds_::Imu_");

            // 计算Imu类型的最大序列化大小，调用Imu类的相关方法获取其最大可能的序列化字节数
            auto type_size = Imu::getMaxCdrSerializedSize();

            // 计算序列化数据的对齐（为了处理可能存在的子消息），根据当前计算出的类型大小按照4字节对齐规则进行调整，确保数据在序列化时符合特定的对齐要求
            type_size += eprosima::fastcdr::Cdr::alignment(type_size, 4);

            // 将类型大小加上4字节的封装大小（ROS 2消息通常采用封装格式），计算出最终包含封装部分的消息总大小，并转换为uint32_t类型赋值给m_typeSize成员变量
            m_typeSize = static_cast<uint32_t>(type_size) + 4;  // encapsulation

            // 检查Imu类型是否定义了键值（key），并保存其状态，后续在获取键值等相关操作时会用到这个状态判断
            m_isGetKeyDefined = Imu::isKeyDefined();

            // 计算Imu类型键的最大序列化大小，如果大于16字节，则选择较大的键长度，否则选择16字节，确定用于存储键值的缓冲区大小
            size_t keyLength = Imu::getKeyMaxCdrSerializedSize() > 16?
                    Imu::getKeyMaxCdrSerializedSize() : 16;

            // 为键值缓冲区分配内存，存储最大可能的键长度，通过malloc函数分配指定字节数的内存空间，并将返回的指针转换为unsigned char*类型赋值给m_keyBuffer成员变量
            m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));

            // 初始化缓冲区内容为零，确保没有未初始化的数据，通过memset函数将分配的内存区域每个字节都设置为0
            memset(m_keyBuffer, 0, keyLength);
        }


        // ImuPubSubType类的析构函数，用于释放构造函数中为键值缓冲区分配的内存资源
        ImuPubSubType::~ImuPubSubType()
        {
            if (m_keyBuffer!= nullptr)
            {
                free(m_keyBuffer);
            }
        }

        // 序列化函数，将给定的Imu类型的数据对象序列化为SerializedPayload_t格式，以便进行传输或存储等操作
        bool ImuPubSubType::serialize(
                void* data,
                SerializedPayload_t* payload)
        {
            // 将传入的void*类型的数据指针转换为Imu*类型指针，以便后续对具体的Imu类型数据进行序列化操作
            Imu* p_type = static_cast<Imu*>(data);

            // 创建一个eprosima::fastcdr::FastBuffer对象，用于管理原始数据缓冲区，将payload中的数据指针和最大缓冲区大小作为参数传递给构造函数，后续通过该对象操作实际要写入序列化数据的缓冲区
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
            // 创建一个eprosima::fastcdr::Cdr对象，用于序列化数据，传入FastBuffer对象以及默认字节序（系统字节序）和DDS_CDR格式参数，使用该对象来执行具体的序列化逻辑
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);
            // 根据Cdr对象的字节序判断封装类型，设置payload的封装类型，如果是大端字节序则设置为CDR_BE，否则设置为CDR_LE
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;
            // 序列化封装头，按照CDR格式要求先处理封装部分的序列化，为后续具体数据的序列化做准备
            ser.serialize_encapsulation();

            try
            {
                // 序列化具体的Imu对象数据，调用Imu类的serialize方法，将Imu对象的数据按照定义好的序列化逻辑写入到Cdr对象中
                p_type->serialize(ser);
            }
            catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                // 如果在序列化过程中出现内存不足的情况，捕获异常并返回false，表示序列化失败
                return false;
            }

            // 获取序列化后的数据长度，通过Cdr对象的相关方法获取已经序列化的数据字节数，并赋值给payload->length成员变量，用于记录实际序列化后的有效数据长度
            payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
            return true;
        }

        // 反序列化函数，将SerializedPayload_t格式的数据反序列化为Imu类型的数据对象，还原出原始的数据内容
        bool ImuPubSubType::deserialize(
                SerializedPayload_t* payload,
                void* data)
        {
            try
            {
                // 将传入的void*类型数据指针转换为Imu类型指针，以便后续将反序列化得到的数据填充到对应的Imu对象中
                Imu* p_type = static_cast<Imu*>(data);

                // 创建一个eprosima::fastcdr::FastBuffer对象，用于管理原始数据缓冲区，将payload中的数据指针和实际数据长度（payload->length）作为参数传递给构造函数，使其管理包含序列化数据的缓冲区
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                // 创建一个eprosima::fastcdr::Cdr对象，用于反序列化数据，传入FastBuffer对象以及默认字节序（系统字节序）和DDS_CDR格式参数，使用该对象来执行具体的反序列化逻辑
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);

                // 反序列化封装头，按照CDR格式要求先处理封装部分的反序列化，恢复数据的结构和顺序信息
                deser.read_encapsulation();

                // 根据反序列化的数据的字节序，设置封装格式（大端或小端），与序列化时的判断逻辑一致，确保字节序的正确处理
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;

                // 反序列化具体的Imu对象数据，调用Imu类的deserialize方法，从Cdr对象中按照定义好的反序列化逻辑读取数据并填充到Imu对象中
                p_type->deserialize(deser);
            }
            catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                // 如果在反序列化过程中出现内存不足的情况，捕获异常并返回false，表示反序列化失败
                return false;
            }

            // 反序列化成功，返回true
            return true;
        }


        // 返回一个函数对象，该函数对象用于获取给定Imu数据对象序列化后的大小（包含封装部分），以方便在其他地方动态获取序列化后的长度信息
        std::function<uint32_t()> ImuPubSubType::getSerializedSizeProvider(
                void* data)
        {
            return [data]() -> uint32_t
                   {
                       // 计算并返回序列化后的大小，先获取Imu对象本身序列化后的大小（调用相关函数获取），再加上封装部分的4字节大小
                       return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Imu*>(data))) +
                              4u /*encapsulation*/;
                   };
        }

        // 创建一个Imu类型的数据对象，并返回其void*指针，用于后续需要创建新的Imu对象进行操作的场景，比如在接收数据后反序列化到新创建的对象中等情况
        void* ImuPubSubType::createData()
        {
            return reinterpret_cast<void*>(new Imu());
        }

        // 删除通过createData函数创建的Imu数据对象，释放其占用的内存资源，避免内存泄漏，通过delete操作符进行内存释放
        void ImuPubSubType::deleteData(
                void* data)
        {
            delete(reinterpret_cast<Imu*>(data));
        }

        // 获取给定Imu数据对象的键（key），并将其填充到InstanceHandle_t结构中，用于在某些场景下（如消息匹配、查找等）进行标识等操作
        bool ImuPubSubType::getKey(
                void* data,
                InstanceHandle_t* handle,
                bool force_md5)
        {
            if (!m_isGetKeyDefined)
            {
                return false;
            }

            Imu* p_type = static_cast<Imu*>(data);

            // 创建一个eprosima::fastcdr::FastBuffer对象，用于管理存储键值序列化数据的原始缓冲区，传入键值缓冲区指针（m_keyBuffer）和Imu类型键的最大序列化大小作为参数，用于后续操作键值的序列化数据
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                    Imu::getKeyMaxCdrSerializedSize());

            // 创建一个eprosima::fastcdr::Cdr对象，用于序列化键值数据，传入FastBuffer对象以及大端字节序（通常在处理键值等标识数据时有特定字节序要求），使用该对象来执行键值的序列化逻辑
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);
            // 调用Imu类的serializeKey方法，将Imu对象的键值按照定义好的序列化逻辑写入到Cdr对象中
            p_type->serializeKey(ser);
            if (force_md5 || Imu::getKeyMaxCdrSerializedSize() > 16)
            {
                // 如果要求强制使用MD5或者键值的最大序列化大小大于16字节，则进行以下MD5相关操作
                m_md5.init();
                m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                m_md5.finalize();
                for (uint8_t i = 0; i < 16; ++i)
                {
                    // 将计算得到的MD5摘要值逐个字节填充到InstanceHandle_t结构的value数组中，用于后续作为唯一标识等用途
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else
            {
                for (uint8_t i = 0; i < 16; ++i)
                {
                    // 如果不满足上述条件，则直接将键值缓冲区中的数据逐个字节填充到InstanceHandle_t结构的value数组中，作为标识数据
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }
    } //End of namespace msg
} //End of namespace sensor_msgs
