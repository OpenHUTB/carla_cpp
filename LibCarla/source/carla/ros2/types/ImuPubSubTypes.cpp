// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file ImuPubSubTypes.cpp
 * This header file contains the implementation of the serialization functions.
 *
 * This file was generated by the tool fastcdrgen.
 */

// 包含FastCDR库中用于管理缓冲区的头文件，FastBuffer类可方便地操作字符缓冲区，例如设置缓冲区大小、获取可用空间等，
// 在序列化和反序列化过程中用于处理数据的存储和读取
#include <fastcdr/FastBuffer.h>
// 包含FastCDR库中用于实现CDR（Common Data Representation，通用数据表示）序列化和反序列化操作的头文件，
// Cdr类提供了一系列函数来处理不同数据类型的序列化和反序列化，按照指定的字节序、格式等规则进行数据转换
#include <fastcdr/Cdr.h>

// 包含自定义的ImuPubSubTypes相关头文件，其中应该定义了ImuPubSubType类的声明以及可能相关的其他类型、函数等，
// 使得当前源文件可以实现该类中定义的各种函数接口，完成与IMU消息类型相关的序列化、反序列化等功能
#include "ImuPubSubTypes.h"

// 使用类型别名，将eprosima::fastrtps::rtps::SerializedPayload_t简化为SerializedPayload_t，提高代码可读性，
// SerializedPayload_t类型通常用于存储序列化后的数据以及相关的元数据（如数据长度、封装格式等信息）
using SerializedPayload_t = eprosima::fastrtps::rtps::SerializedPayload_t;
// 同样使用类型别名，将eprosima::fastrtps::rtps::InstanceHandle_t简化为InstanceHandle_t，方便后续代码中对该类型的使用，
// InstanceHandle_t类型可能用于在数据分发服务（如DDS）中唯一标识一个数据实例，常用于查找、匹配等操作
using InstanceHandle_t = eprosima::fastrtps::rtps::InstanceHandle_t;

namespace sensor_msgs {
    namespace msg {

        // ImuPubSubType类的构造函数，用于初始化与IMU消息类型相关的各种属性和资源，在创建该类型对象时被调用
        ImuPubSubType::ImuPubSubType()
        {
            // 设置类型的名称为 "sensor_msgs::msg::dds_::Imu_"，这是ROS 2中的IMU消息类型，
            // 通过调用某个（可能是基类提供的）setName函数来设置名称，这个名称在整个消息系统中用于唯一标识该类型的消息，
            // 方便在发布、订阅以及其他消息处理环节中进行区分和识别
            setName("sensor_msgs::msg::dds_::Imu_");

            // 计算Imu类型的最大序列化大小，通过调用Imu类（应该是自定义的表示IMU消息内容的类）的静态函数getMaxCdrSerializedSize来获取，
            // 这个大小反映了在最复杂情况下（例如所有成员变量都取到最大可能值时），将Imu类型的数据序列化为CDR格式所需要的字节数，
            // 为后续内存分配、缓冲区设置等操作提供基础数据
            auto type_size = Imu::getMaxCdrSerializedSize();

            // 计算序列化数据的对齐（为了处理可能存在的子消息），调用Cdr类的alignment函数对前面得到的类型大小进行对齐调整，
            // 传入的参数表示按照4字节对齐，目的是使序列化后的数据在内存中的布局符合一定的对齐规则，这有助于提高数据访问效率以及与某些系统要求的兼容性，
            // 例如某些硬件平台在读取特定对齐的数据时性能更好，或者一些通信协议要求数据按照特定对齐方式进行传输
            type_size += eprosima::fastcdr::Cdr::alignment(type_size, 4);

            // 将类型大小加上4字节的封装大小（ROS 2消息通常采用封装格式），在ROS 2消息体系中，会额外添加一些字节用于存放如消息头部、标识等信息，
            // 这里将调整后的类型大小加上4字节后转换为uint32_t类型，并赋值给m_typeSize成员变量，用于记录整个Imu消息类型序列化后的总体大小（包含封装部分），
            // 后续在处理消息的发送、接收以及内存管理等操作时会用到这个总体大小信息
            m_typeSize = static_cast<uint32_t>(type_size) + 4;  // encapsulation

            // 检查Imu类型是否定义了键值（key），通过调用Imu类的静态函数isKeyDefined来判断，
            // 并将判断结果（布尔值）保存到m_isGetKeyDefined成员变量中，后续在获取键值等相关操作时会依据这个变量来确定是否可以执行相应操作，
            // 如果没有定义键值，那么一些依赖键值的功能（如根据键值查找消息等）就无法进行
            m_isGetKeyDefined = Imu::isKeyDefined();

            // 计算Imu类型键的最大序列化大小，如果大于16字节，则选择较大的键长度，否则选择16字节，
            // 通过比较Imu::getKeyMaxCdrSerializedSize函数返回的键最大序列化大小与16字节的大小关系，来确定合适的键缓冲区长度，
            // 这是因为在某些情况下可能对键的长度有一定限制或者为了统一处理，选择一个合适的固定长度（最大为实际最大长度或者16字节）来分配键缓冲区内存
            size_t keyLength = Imu::getKeyMaxCdrSerializedSize() > 16?
                    Imu::getKeyMaxCdrSerializedSize() : 16;

            // 为键值缓冲区分配内存，使用malloc函数分配指定长度（keyLength）的无符号字符类型（unsigned char*）内存空间，
            // 这块内存将用于存储与键相关的数据，例如键的序列化表示等内容，确保后续在生成、处理键值时有足够的空间来操作
            m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));

            // 初始化缓冲区内容为零，使用memset函数将刚分配的键缓冲区的所有字节都设置为0，
            // 这样做可以确保缓冲区初始状态是确定的，避免出现未初始化的数据造成后续操作的不确定性或错误，例如在使用键缓冲区数据进行比较、赋值等操作时，
            // 初始化为零可以保证有一个明确的初始值，防止出现意外的结果
            memset(m_keyBuffer, 0, keyLength);
        }

        // ImuPubSubType类的析构函数，用于释放构造函数中分配的键缓冲区内存资源，在对象生命周期结束时被自动调用，避免内存泄漏
        ImuPubSubType::~ImuPubSubType()
        {
            // 检查键缓冲区指针m_keyBuffer是否为空，如果不为空，表示之前成功分配了内存，
            // 则调用free函数释放对应的内存空间，将其归还给操作系统，保证内存资源的正确管理
            if (m_keyBuffer!= nullptr)
            {
                free(m_keyBuffer);
            }
        }

        // 序列化函数，将给定的Imu类型数据对象序列化为SerializedPayload_t格式，以便进行消息的传输、存储等操作，若序列化成功返回true，否则返回false
        bool ImuPubSubType::serialize(
                void* data,
                SerializedPayload_t* payload)
        {
            // 将传入的void*类型数据指针转换为Imu*类型指针，这样就能以Imu类型的方式正确访问和操作传入的数据对象，
            // 确保可以调用Imu类中定义的与序列化相关的成员函数等进行后续操作，例如对Imu对象中的各个成员变量按照CDR格式进行序列化处理
            Imu* p_type = static_cast<Imu*>(data);

            // 创建一个eprosima::fastcdr::FastBuffer对象，用于管理原始缓冲区（raw buffer），
            // 它通过reinterpret_cast将payload->data（这是一个char*类型的指针，指向实际存储数据的内存区域）转换为合适的类型，
            // 并结合payload->max_size（表示缓冲区的最大可用空间大小）来初始化FastBuffer对象，
            // 后续通过这个对象可以方便地对缓冲区进行读写操作，同时也限定了序列化数据可使用的最大空间范围，避免缓冲区溢出等问题
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);

            // 创建一个eprosima::fastcdr::Cdr对象，用于执行实际的序列化数据操作，
            // 它关联了前面创建的FastBuffer对象fastbuffer，同时指定了字节序（DEFAULT_ENDIAN，通常为系统默认字节序）
            // 和遵循的CDR规范（DDS_CDR，特定于数据分发服务（Data Distribution Service，DDS）系统的CDR格式要求），
            // 这个Cdr对象提供了一系列用于序列化不同数据类型的函数接口，方便按照相应规则对数据进行序列化处理
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);

            // 根据Cdr对象当前的字节序（endianness）来设置payload的封装格式（encapsulation），
            // 如果ser对象的字节序是大端序（BIG_ENDIANNESS），则将payload的封装格式设置为CDR_BE，否则设置为CDR_LE，
            // 封装格式用于明确数据在传输或存储时字节的排列顺序，接收方在反序列化时需要按照相同的格式进行解析，以保证数据的正确还原
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;

            // 使用Cdr对象对封装进行序列化操作，这一步可能是在数据前面添加一些必要的封装头部等信息，
            // 按照CDR规范为整个要序列化的数据构建合适的结构，使得序列化后的数据符合特定的格式要求，方便后续的传输和处理，例如在网络传输中便于识别和解析消息
            ser.serialize_encapsulation();

            try
            {
                // 调用Imu类型对象的serialize函数（假设Imu类中定义了这个函数用于序列化自身的数据成员），
                // 通过传入前面创建的Cdr对象ser，将Imu类型对象的数据按照CDR格式序列化到对应的缓冲区中，
                // 如果在序列化过程中出现内存不足等异常情况，会抛出相应的异常并在catch块中进行处理
                p_type->serialize(ser);
            }
            catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                // 如果捕获到内存不足的异常，说明序列化操作无法正常完成，此时返回false，表示序列化失败，
                // 这样调用者可以根据返回值知晓序列化是否成功，并采取相应的措施（如重新分配更大的缓冲区、提示错误等）
                return false;
            }

            // 获取经过序列化后的数据实际长度，通过调用ser对象的getSerializedDataLength函数获取已序列化数据的长度，
            // 并将其赋值给payload的length成员变量，这样后续使用payload时可以知道实际有效数据的长度，便于进行后续处理，
            // 比如在消息传输时知道要发送的数据量大小，或者在接收端验证接收到的数据长度是否符合预期等
            payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());

            // 表示序列化操作成功完成，返回true，意味着已经将Imu类型的数据正确地序列化为SerializedPayload_t格式，并且相关的长度等信息也已正确设置
            return true;
        }

        // 反序列化函数，将SerializedPayload_t格式的数据反序列化为Imu类型的数据对象，实现从存储或传输格式到实际可用数据对象的转换，若反序列化成功返回true，否则返回false
        bool ImuPubSubType::deserialize(
                SerializedPayload_t* payload,
                void* data)
        {
            try
            {
                // 将传入的void*类型数据指针转换为Imu*类型指针，以便后续能以Imu类型的方式正确操作和填充数据，
                // 使得反序列化得到的数据能够准确地赋值给对应的Imu类型对象的各个成员变量，还原出原始的Imu类型数据对象
                Imu* p_type = static_cast<Imu*>(data);

                // 创建一个eprosima::fastcdr::FastBuffer对象，用于管理原始数据缓冲区，
                // 它通过reinterpret_cast将payload->data（指向实际存储数据的内存区域）转换为合适的类型，
                // 并使用payload->length（表示实际数据的长度）来限定缓冲区的有效范围，确保后续反序列化操作只处理有效数据部分，
                // 避免读取超出实际数据长度的内存区域，造成错误或异常情况
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                // 创建一个eprosima::fastcdr::Cdr对象，用于执行反序列化数据操作，
                // 它关联了前面创建的FastBuffer对象fastbuffer，同时指定了字节序（DEFAULT_ENDIAN，通常为系统默认字节序）
                // 和遵循的CDR规范（DDS_CDR，符合特定的DDS系统要求的CDR格式），
                // 这个Cdr对象提供了一系列用于反序列化不同数据类型的函数接口，以便按照相应规则从缓冲区中解析出数据并还原为Imu类型对象
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);

                // 反序列化封装头（处理序列化数据的结构和顺序），通过调用Cdr对象的read_encapsulation函数，
                // 按照之前序列化时构建的封装格式，解析出相关的头部信息，例如字节序等信息，为后续正确反序列化数据做准备，
                // 确保在解析具体的数据内容时按照正确的规则进行，保证数据还原的准确性
                deser.read_encapsulation();

                // 根据反序列化得到的Cdr对象deser的字节序，设置payload的封装格式（encapsulation），
                // 如果是大端序（BIG_ENDIANNESS）则设置为CDR_BE，否则设置为CDR_LE，保持与序列化时一致的封装格式标识，
                // 方便后续在其他相关操作（如再次序列化、验证数据等）中能够依据正确的封装格式进行处理
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;

                // 调用Imu类型对象的deserialize函数（假设Imu类中定义了这个函数用于从CDR格式数据反序列化自身的数据成员），
                // 通过传入前面创建的Cdr对象deser，将缓冲区中的数据按照CDR格式反序列化为Imu类型对象的数据，填充到对应的Imu类型对象的各个成员变量中，
                // 完成从序列化数据到原始Imu类型数据对象的还原过程
                p_type->deserialize(deser);
            }
            catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                // 如果在反序列化过程中捕获到内存不足的异常，说明反序列化操作无法正常完成，此时返回false，表示反序列化失败，
                // 以便调用者根据返回值进行相应的错误处理，比如提示用户数据可能损坏、重新请求数据等操作
                return false;
            }

            // 表示反序列化操作成功完成，返回true，意味着已经成功将传入的SerializedPayload_t格式的数据还原为了Imu类型的可用数据对象，
            // 可以在后续的程序逻辑中继续使用这个反序列化得到的数据对象进行相关操作，如进行数据处理、业务逻辑判断等
            return true;
        }

        // 返回一个函数对象（lambda表达式），该函数对象用于获取给定Imu数据对象序列化后的大小（包含封装部分），
        // 方便在需要知道特定Imu数据序列化后占据空间大小的场景中进行调用获取相应信息，例如在分配缓冲区、统计消息大小等操作时使用
        std::function<uint32_t()> ImuPubSubType::getSerializedSizeProvider(
                void* data)
        {
            return [data]() -> uint32_t
                   {
                       // 先获取Imu类型数据对象的CDR序列化大小，通过调用type（这里可能是一个命名空间或者类型别名相关的标识，假设对应的getCdrSerializedSize函数存在且正确实现）
                       // 的getCdrSerializedSize函数，并传入转换后的Imu*类型指针所指向的数据对象，获取其序列化大小，
                       // 然后再加上4字节（用于考虑封装（encapsulation）所需的额外空间），最终返回总的序列化大小，
                       return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Imu*>(data))) +
                              4u /*encapsulation*/;
                   };
        }

// 创建一个新的Imu类型的数据对象，并将其指针转换为void*类型返回，
// 通常用于在需要动态分配对应类型数据空间的场景中，例如在接收消息前准备好存储消息数据的对象，方便后续进行数据填充等操作
        void* ImuPubSubType::createData()
        {
            return reinterpret_cast<void*>(new Imu());
        }

        // 删除给定的Imu类型数据对象，通过将void*类型指针转换为Imu*类型指针，然后调用delete操作符来释放内存，
        // 用于清理之前动态分配的Imu类型数据对象所占用的内存空间，避免内存泄漏，保证内存资源的有效管理，
        // 一般在数据使用完毕后调用该函数来释放相应内存资源。
        void ImuPubSubType::deleteData(
                void* data)
        {
            delete(reinterpret_cast<Imu*>(data));
        }

        // 获取给定Imu数据对象的键（Key）信息，并填充到InstanceHandle_t结构中，根据情况可能计算MD5值等操作，
        // 键信息通常用于在消息分发、查找等场景中快速定位和区分不同的消息实例，通过唯一的键值可以高效地对消息进行管理和匹配。
        bool ImuPubSubType::getKey(
                void* data,
                InstanceHandle_t* handle,
                bool force_md5)
        {
            // 首先检查是否定义了获取键的操作，通过判断m_isGetKeyDefined成员变量的值（该值在构造函数中根据Imu类型是否定义键来初始化），
            // 如果没有定义获取键的操作（即m_isGetKeyDefined为false），则直接返回false，表示无法获取键信息，
            // 避免后续进行无效的操作而可能引发错误。
            if (!m_isGetKeyDefined)
            {
                return false;
            }

            // 将传入的void*类型数据指针转换为Imu*类型指针，以便后续操作对应的Imu类型对象，进行与键相关的序列化等操作，
            // 这样就能调用Imu类中特定的与键相关的函数（如serializeKey等）来处理键数据。
            Imu* p_type = static_cast<Imu*>(data);

            // 创建一个eprosima::fastcdr::FastBuffer对象，用于管理用于存储键数据的缓冲区，
            // 它通过reinterpret_cast将m_keyBuffer（之前在构造函数中分配的键缓冲区指针）转换为合适的类型，
            // 并结合Imu::getKeyMaxCdrSerializedSize()（获取Imu类型键的最大序列化大小）来限定缓冲区的范围，
            // 这个缓冲区将用于后续的键数据序列化操作，确保有合适的空间来暂存键的序列化表示，以便进一步处理键信息。
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                    Imu::getKeyMaxCdrSerializedSize());

            // 创建一个eprosima::fastcdr::Cdr对象，用于序列化键数据，
            // 这里指定了字节序为大端序（BIG_ENDIANNESS），然后使用该对象对Imu对象的键进行序列化操作（调用Imu类的serializeKey函数，假设其存在且正确实现），
            // 将Imu类型对象中与键相关的数据按照指定字节序和CDR格式序列化到对应的缓冲区中，为后续生成键值做准备。
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);
            p_type->serializeKey(ser);

            // 判断是否需要强制计算MD5值或者Imu类型的键最大CDR序列化大小是否大于16字节，
            // 如果满足这两个条件中的任意一个，就需要进行MD5计算及相关处理，通常用于生成更具唯一性和稳定性的键标识，便于在复杂的消息环境中准确区分不同消息实例。
            if (force_md5 || Imu::getKeyMaxCdrSerializedSize() > 16)
            {
                // 初始化MD5计算相关的对象（假设m_md5是一个用于MD5计算的合适对象且有对应的init等函数），
                // 这一步准备好进行MD5计算所需的内部状态等信息，例如初始化相关的哈希算法参数等，确保后续计算能正确进行。
                m_md5.init();
                // 使用MD5对象更新数据，传入键缓冲区（m_keyBuffer）和序列化后的键数据长度（通过ser.getSerializedDataLength()获取），
                // 以便MD5计算对象依据这些数据来逐步计算哈希值，它会根据传入的数据内容按照MD5算法规则进行计算，生成对应的哈希摘要。
                m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                // 完成MD5计算，生成最终的MD5摘要值，此步骤会根据前面更新的数据进行最后的哈希计算，得到一个固定长度（通常是16字节）的摘要信息，
                // 用于唯一标识该键对应的Imu对象相关信息，便于后续的比较、查找等操作，确保不同的Imu消息实例能通过这个唯一的键标识进行区分。
                m_md5.finalize();
                // 将计算得到的MD5摘要值的每个字节依次复制到InstanceHandle_t结构的value数组中，
                // InstanceHandle_t结构可能用于在消息系统中唯一标识某个消息实例等用途，通过将MD5值存入其中，
                // 后续可以基于这个值来快速判断不同消息实例是否对应相同的Imu对象（基于键的角度），实现高效的消息匹配和管理。
                for (uint8_t i = 0; i < 16; ++i)
                {
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else
            {
                // 如果不需要计算MD5值且键大小不大于16字节，则直接将键缓冲区（m_keyBuffer）中的数据复制到InstanceHandle_t结构的value数组中，
                // 这种情况可能是键本身比较简单或者有其他特定的处理逻辑使得不需要进行MD5计算来生成唯一标识，直接使用原始键数据即可满足需求。
                for (uint8_t i = 0; i < 16; ++i)
                {
                    handle->value[i] = m_keyBuffer[i];
                }
            }

            // 表示成功获取并处理了键信息，返回true，意味着已经按照相应规则将键相关的数据填充到了InstanceHandle_t结构中，
            // 可以供外部进一步使用，比如在消息匹配、查找等操作中基于这个键信息进行相应的判断和处理，完成了获取键值这一功能操作。
            return true;
        }
    }
} 

