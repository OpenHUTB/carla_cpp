// Copyright (c) 2020 Computer Vision Center (CVC) at the Universitat Autonoma
// de Barcelona (UAB).
//
// This work is licensed under the terms of the MIT license.
// For a copy, see <https://opensource.org/licenses/MIT>.

#pragma once

#include "carla/rpc/Location.h"

#include <cstdint>
#include <vector>
#include <numeric>

namespace carla {

namespace ros2 {
  class ROS2;
}

namespace sensor {

namespace s11n {
  class SemanticLidarSerializer;
  class SemanticLidarHeaderView;
}

namespace data {

  /// Helper class to store and serialize the data generated by a RawLidar.
  ///
  /// The header of a Lidar measurement consists of an array of uint32_t's in
  /// the following layout
  ///
  ///    {
  ///      Horizontal angle (float),
  ///      Channel count,
  ///      Point count of channel 0,
  ///      ...
  ///      Point count of channel n,
  ///    }
  ///
  /// The points are stored in an array of detections, each detection consist in
  /// four floats, the point detected and the angle between the casted ray and
  /// the normal of the hitted object, and two unsigned integers, the index
  /// and the semantic tag of the hitted object
  ///
  ///    {
  ///      X0, Y0, Z0, Cos(TH0), idx_0, tag_0
  ///      ...
  ///      Xn, Yn, Zn, Cos(THn), idx_n, tag_n
  ///    }
  ///

  #pragma pack(push, 1)
  class SemanticLidarDetection {
    public:
      geom::Location point{};
      float cos_inc_angle{};
      uint32_t object_idx{};
      uint32_t object_tag{};

      SemanticLidarDetection() = default;

      SemanticLidarDetection(float x, float y, float z, float cosTh, uint32_t idx, uint32_t tag) :
          point(x, y, z), cos_inc_angle{cosTh}, object_idx{idx}, object_tag{tag} { }
      SemanticLidarDetection(geom::Location p, float cosTh, uint32_t idx, uint32_t tag) :
          point(p), cos_inc_angle{cosTh}, object_idx{idx}, object_tag{tag} { }

      void WritePlyHeaderInfo(std::ostream& out) const{
        out << "property float32 x\n" \
           "property float32 y\n" \
           "property float32 z\n" \
           "property float32 CosAngle\n" \
           "property uint32 ObjIdx\n" \
           "property uint32 ObjTag";
      }

      void WriteDetection(std::ostream& out) const{
        out << point.x << ' ' << point.y << ' ' << point.z << ' ' \
          << cos_inc_angle << ' ' << object_idx << ' ' << object_tag;
      }
  };
  #pragma pack(pop)
// 使用静态断言来检查 `float` 类型的大小是否和 `uint32_t` 类型的大小相等，若不相等则在编译时输出指定的错误信息 "Invalid float size"
  class SemanticLidarData {
    static_assert(sizeof(float) == sizeof(uint32_t), "Invalid float size");

  protected:
    // 定义一个名为 `Index` 的强类型枚举（enum class），其底层类型为 `size_t`，用于表示不同的索引含义
    enum Index : size_t {
// 表示水平角度对应的索引，枚举值
      HorizontalAngle,
 // 表示通道数量对应的索引，枚举值
      ChannelCount,
  // 用于表示总的大小相关的一个枚举值，可能作为一种边界或者偏移量相关的标识，具体取决于使用场景
      SIZE
    };

  public:
// 显式的构造函数，参数 `ChannelCount` 有默认值 `0u`，用于初始化 `SemanticLidarData` 类的对象
    explicit SemanticLidarData(uint32_t ChannelCount = 0u)
// 使用初始化列表初始化 `_header` 成员变量，将其大小初始化为 `Index::SIZE + ChannelCount`，并将所有元素初始化为 `0u`
      : _header(Index::SIZE + ChannelCount, 0u) {
// 将 `_header` 向量中对应 `Index::ChannelCount` 索引位置的元素设置为传入的通道数量 `ChannelCount`
      _header[Index::ChannelCount] = ChannelCount;
    }
    // 默认实现移动赋值运算符，这里使用 `= default` 语法让编译器自动生成默认的移动赋值操作逻辑，以提高代码简洁性
    SemanticLidarData &operator=(SemanticLidarData &&) = default;
    // 虚析构函数，用于在派生类对象销毁时进行正确的资源清理等操作，这里为空实现，具体清理逻辑可在派生类中按需重写
    virtual ~SemanticLidarData() {}
 // 获取水平角度的函数，返回值类型为 `float`，通过将 `_header` 中对应 `Index::HorizontalAngle` 索引位置的元素进行类型重解释转换为 `float` 类型后返回
    float GetHorizontalAngle() const {
      return reinterpret_cast<const float &>(_header[Index::HorizontalAngle]);
    }
 // 设置水平角度的函数，参数 `angle` 为要设置的角度值（`float` 类型）
    void SetHorizontalAngle(float angle) {
      std::memcpy(&_header[Index::HorizontalAngle], &angle, sizeof(uint32_t));
    }
// 获取通道数量的函数，返回值类型为 `uint32_t`，直接返回 `_header` 向量中对应 `Index::ChannelCount` 索引位置的元素值
    uint32_t GetChannelCount() const {
      return _header[Index::ChannelCount];
    }
 // 虚函数，用于重置内存相关操作，参数 `points_per_channel` 是一个存储每个通道点数的无符号32位整数向量，具体重置逻辑可能因不同派生类而有差异（因为是虚函数）
    virtual void ResetMemory(std::vector<uint32_t> points_per_channel) {
        // 使用断言来确保当前对象的通道数量大于传入的 `points_per_channel` 向量的大小，可能是基于某种前置逻辑要求做的检查，若不满足条件则会触发调试断言失败（具体行为取决于 `DEBUG_ASSERT` 的实现）
      DEBUG_ASSERT(GetChannelCount() > points_per_channel.size());
  // 使用 `std::memset` 函数将 `_header` 数据（从 `Index::SIZE` 位置开始）所指向的内存区域设置为 `0`，设置的字节数为 `sizeof(uint32_t) * GetChannelCount()`，也就是按照每个通道对应 `uint32_t` 大小的空间来进行内存清零操作
      std::memset(_header.data() + Index::SIZE, 0, sizeof(uint32_t) * GetChannelCount());

      uint32_t total_points = static_cast<uint32_t>(
          std::accumulate(points_per_channel.begin(), points_per_channel.end(), 0));
// 清空 _ser_points 向量，通常用于清除之前存储的数据，以便重新填充新的数据
      _ser_points.clear();
// 为 _ser_points 向量预留足够的空间，以容纳 total_points 个元素，避免后续插入元素时频繁重新分配内存，提高性能
      _ser_points.reserve(total_points);
    }
// 虚函数，用于写入通道计数信息。参数 points_per_channel 是一个存储每个通道点数的无符号32位整数向量
    virtual void WriteChannelCount(std::vector<uint32_t> points_per_channel) {
// 循环遍历每个通道，idxChannel 从0开始，直到通道数量（通过 GetChannelCount() 获取
      for (auto idxChannel = 0u; idxChannel < GetChannelCount(); ++idxChannel)
 // 将 points_per_channel 中对应通道索引的点数赋值给 _header 向量中相应的位置，Index::SIZE 应该是一个自定义的索引偏移量相关的常量之类的
        _header[Index::SIZE + idxChannel] = points_per_channel[idxChannel];
    }
// 虚函数，用于写入点同步信息，参数 detection 是一个语义激光雷达检测相关的对象
    virtual void WritePointSync(SemanticLidarDetection &detection) {
 // 将传入的 SemanticLidarDetection 类型的 detection 对象添加到 _ser_points 向量末尾
      _ser_points.emplace_back(detection);
    }
// 受保护的成员变量，用于存储一些头部相关的信息，元素类型是无符号32位整数
  protected:
    std::vector<uint32_t> _header;
// 用于存储每个通道最大点数的无符号32位整数变量
    uint32_t _max_channel_points;
// 私有成员变量，用于存储语义激光雷达检测相关对象的向量，也就是具体的检测数据集合
  private:
    std::vector<SemanticLidarDetection> _ser_points;

// 声明友元类，允许 s11n::SemanticLidarHeaderView 类访问当前类的私有和受保护成员
  friend class s11n::SemanticLidarHeaderView;
// 声明友元类，允许 s11n::SemanticLidarSerializer 类访问当前类的私有和受保护成员
  friend class s11n::SemanticLidarSerializer;
// 声明友元类，允许 carla::ros2::ROS2 类访问当前类的私有和受保护成员
  friend class carla::ros2::ROS2;

  };

} // namespace s11n
} // namespace sensor
} // namespace carla
