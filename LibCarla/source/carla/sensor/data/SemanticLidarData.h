// Copyright (c) 2020 Computer Vision Center (CVC) at the Universitat Autonoma
// de Barcelona (UAB).
//
// This work is licensed under the terms of the MIT license.
// For a copy, see <https://opensource.org/licenses/MIT>.

#pragma once

#include "carla/rpc/Location.h"

#include <cstdint>
#include <vector>
#include <numeric>
// 定义carla命名空间
namespace carla {
// ros2子命名空间
namespace ros2 {
  class ROS2;
}
//对传感器数据处理等相关的类定义
namespace sensor {
// s11n子命名空间空间，这里前置声明了语义激光雷达相关的序列化器和头视图类
namespace s11n {
  class SemanticLidarSerializer;
  class SemanticLidarHeaderView;
}
// data子命名空间，用于存放和传感器数据具体表示、操作相关的类，下面定义了语义激光雷达数据处理相关的类
namespace data {

  /// Helper class to store and serialize the data generated by a RawLidar.
  ///
  /// The header of a Lidar measurement consists of an array of uint32_t's in
  /// the following layout
  ///
  ///    {
  ///      Horizontal angle (float),
  ///      Channel count,
  ///      Point count of channel 0,
  ///      ...
  ///      Point count of channel n,
  ///    }
  ///
  /// The points are stored in an array of detections, each detection consist in
  /// four floats, the point detected and the angle between the casted ray and
  /// the normal of the hitted object, and two unsigned integers, the index
  /// and the semantic tag of the hitted object
  ///
  ///    {
  ///      X0, Y0, Z0, Cos(TH0), idx_0, tag_0
  ///      ...
  ///      Xn, Yn, Zn, Cos(THn), idx_n, tag_n
  ///    }
  /// @brief SemanticLidarDetection类，作为辅助类，用于存储和序列化由原始激光雷达（RawLidar）生成的数据中的单个检测信息。
   /// @details 一个激光雷达测量的头部信息由一个uint32_t类型的数组构成，其布局如下所述，而每个检测点（SemanticLidarDetection）包含了位置、角度以及被检测物体的索引和语义标签等信息，方便后续对激光雷达检测数据的处理和存储。

  #pragma pack(push, 1)
  class SemanticLidarDetection {
    public:
      geom::Location point{};/// 表示检测到的点的位置信息
      float cos_inc_angle{};/// 表示检测光线与被击中物体法线之间夹角的余弦值，初始化为0。
      uint32_t object_idx{};/// 被检测物体的索引
      uint32_t object_tag{}; /// 被检测物体的语义标签
//默认构造函数，使用类成员的默认初始化方式创建对象
      SemanticLidarDetection() = default;
/// 构造函数，根据给定的坐标值、夹角余弦值、物体索引和语义标签来初始化对象，方便从具体数值创建检测点对象。
/// 检测点的x坐标值。
/// y 检测点的y坐标值。
 /// @param z 检测点的z坐标值。
 /// @param cosTh 检测光线与被击中物体法线之间夹角的余弦值。
 /// @param idx 被检测物体的索引。
 /// @param tag 被检测物体的语义标签。
      SemanticLidarDetection(float x, float y, float z, float cosTh, uint32_t idx, uint32_t tag) :
          point(x, y, z), cos_inc_angle{cosTh}, object_idx{idx}, object_tag{tag} { }
 /// @brief 构造函数，根据给定的位置对象、夹角余弦值、物体索引和语义标签来初始化对象，同样用于创建检测点对象，只是参数形式使用已有的位置对象。
 /// @param p 表示检测点位置的geom::Location类型对象。
/// @param cosTh 检测光线与被击中物体法线之间夹角的余弦值。
  /// @param idx 被检测物体的索引。
  /// @param tag 被检测物体的语义标签。
      SemanticLidarDetection(geom::Location p, float cosTh, uint32_t idx, uint32_t tag) :
          point(p), cos_inc_angle{cosTh}, object_idx{idx}, object_tag{tag} { }
/// @brief 将该检测点相关的属性信息以PLY文件格式的头部信息形式写入到给定的输出流中，PLY文件常用于存储三维模型等数据，这里可能用于后续将激光雷达数据保存为PLY格式时写入头部相关描述信息。
 /// @param out 指向输出流对象（例如文件输出流等）的引用，用于写入数据。
      void WritePlyHeaderInfo(std::ostream& out) const{
        out << "property float32 x\n" \
           "property float32 y\n" \
           "property float32 z\n" \
           "property float32 CosAngle\n" \
           "property uint32 ObjIdx\n" \
           "property uint32 ObjTag";
      }
/// @brief 将该检测点的具体数据（坐标、夹角余弦值、物体索引和语义标签）写入到给定的输出流中，用于将单个检测点的数据输出到流中，可能用于保存数据或者传输等操作。
 /// @param out 指向输出流对象（例如文件输出流等）的引用，用于写入数据     
      void WriteDetection(std::ostream& out) const{
        out << point.x << ' ' << point.y << ' ' << point.z << ' ' \
          << cos_inc_angle << ' ' << object_idx << ' ' << object_tag;
      }
  };
  #pragma pack(pop)
/// @brief SemanticLidarData类，用于存储和操作语义激光雷达整体的数据，包括头部信息、各通道数据等，并且提供了一些对数据进行设置、获取和修改的方法。

  class SemanticLidarData {
    static_assert(sizeof(float) == sizeof(uint32_t), "Invalid float size");
//静态断言，用于在编译时期检查 `float` 类型的大小是否与 `uint32_t` 类型的大小相等。
// 之所以进行这样的检查，是因为后续代码在内存操作等方面可能基于二者大小一致的假设来实现某些功能，
// 如果大小不相等，编译时就会报错，并显示 "Invalid float size" 这个错误提示信息。
  protected:
// 定义一个枚举类型 `Index`，用于清晰地标识存储在 `_header` 向量中的不同数据元素的位置索引，方便代码的可读性和维护性。
    // 这里定义了三个索引值，分别对应水平角度、通道数量以及整个数据结构的总大小（以一种相对抽象的方式表示）。
    enum Index : size_t {
      HorizontalAngle,// 表示水平角度信息在 `_header` 向量中的存储位置索引
      ChannelCount,// 表示通道数量信息在 `_header` 向量中的存储位置索引
      SIZE// 表示整个数据结构中与头部相关部分的总大小索引
    };

  public:
// 构造函数，用于创建 `SemanticLidarData` 类的对象。
    explicit SemanticLidarData(uint32_t ChannelCount = 0u)
// 使用初始化列表初始化 `_header` 成员变量，它是一个 `std::vector<uint32_t>` 类型的向量。
// 根据传入的通道数量（或者默认的0）来确定 `_header` 向量的初始大小，初始化为全部元素值为0。
// 具体大小是 `Index::SIZE + ChannelCount`，意味着预留了存储水平角度、通道数量以及每个通道相关信息（比如每个通道点数等，后续可按需填充）的空间。
      : _header(Index::SIZE + ChannelCount, 0u) {
        // 将 `_header` 向量中对应通道数量的位置设置为传入的 `ChannelCount` 参数值，确保 `_header` 中正确记录了当前对象所表示的激光雷达的通道数量信息。
      _header[Index::ChannelCount] = ChannelCount;
    }
// 移动赋值运算符，这里使用默认生成的移动赋值操作实现。
// 移动赋值运算符允许将一个 `SemanticLidarData` 对象的资源（例如动态分配的内存、已存储的数据等）高效地移动到另一个对象中，
// 避免了像普通赋值那样进行深拷贝带来的不必要的性能开销，常用于对象之间数据所有权转移的场景，比如在容器中重新分配元素等情况。
    SemanticLidarData &operator=(SemanticLidarData &&) = default;
    SemanticLidarData &operator=(SemanticLidarData &&) = default;
// 虚析构函数，定义为虚函数是为了支持多态的销毁机制。
// 当通过基类指针或引用删除派生类对象时，能够正确地调用派生类的析构函数，进而释放派生类中额外申请的资源（如果有）。
// 虽然在当前类中没有明显看到需要释放的特定资源，但这样的定义为后续可能的继承扩展做了准备，确保在多态场景下内存管理的正确性。
    virtual ~SemanticLidarData() {}
// 获取激光雷达测量的水平角度值的函数，该函数为 `const` 成员函数，表示不会修改对象的内部状态。
// 通过将 `_header` 向量中对应 `Index::HorizontalAngle` 索引位置的数据重新解释为 `float` 类型来获取角度值并返回。
// 这里利用了 `reinterpret_cast` 进行类型转换，前提是前面提到的 `float` 和 `uint32_t` 大小一致的假设成立，才能保证这样的转换在内存层面是合理的。
    float GetHorizontalAngle() const {
      return reinterpret_cast<const float &>(_header[Index::HorizontalAngle]);
    }
// 设置激光雷达测量的水平角度值的函数，用于更新对象中存储的水平角度信息。
// 通过 `std::memcpy` 函数将给定的 `angle` 参数（`float` 类型的角度值）以内存拷贝的方式复制到 `_header` 向量中对应 `Index::HorizontalAngle` 索引位置，
// 覆盖原来存储在该位置的数据，实现角度值的更新。拷贝的数据大小为 `sizeof(uint32_t)`，同样依赖于前面提到的类型大小一致性假设。
    void SetHorizontalAngle(float angle) {
    void SetHorizontalAngle(float angle) {
      std::memcpy(&_header[Index::HorizontalAngle], &angle, sizeof(uint32_t));
    }
// 获取激光雷达的通道数量的函数，为 `const` 成员函数，直接返回 `_header` 向量中对应 `Index::ChannelCount` 索引位置存储的 `uint32_t` 类型的数值，
// 该数值在对象构造时或者后续通过相关函数修改通道数量时被设置，反映了当前激光雷达数据对应的通道数量情况。
    uint32_t GetChannelCount() const {
      return _header[Index::ChannelCount];
    }
// 虚函数，用于重置内存相关的数据结构，根据传入的每个通道的点数列表来重新初始化内部存储的数据信息。
// 通常在需要重新使用该对象存储新的激光雷达数据，或者清除已有数据进行重新配置等场景下调用。
    virtual void ResetMemory(std::vector<uint32_t> points_per_channel) {
      // 使用 `DEBUG_ASSERT` 进行调试断言检查，确保当前对象记录的通道数量大于传入的每个通道点数列表的大小。
      // 这是一种调试手段，在开发过程中如果这个条件不满足，意味着数据设置可能不符合预期逻辑（比如通道点数总和超过了总的通道容量等情况），
      // 会触发断言失败提示，帮助开发者发现代码中的潜在问题，但在发布版本中，这个断言可能会被优化掉（取决于具体的编译配置和实现方式）。
      DEBUG_ASSERT(GetChannelCount() > points_per_channel.size());
      // 将 `_header` 向量中从表示总大小（`Index::SIZE`）之后的数据区域全部清零，即清除之前存储的每个通道的点数相关信息，为重新设置做准备。
      // 通过 `std::memset` 函数按字节进行内存设置，设置的字节数为每个通道数量乘以 `sizeof(uint32_t)`，确保整个通道点数相关区域都被重置为0。
      std::memset(_header.data() + Index::SIZE, 0, sizeof(uint32_t) * GetChannelCount());
      // 计算所有通道的总点数，通过使用 `std::accumulate` 函数对传入的每个通道点数列表进行求和操作，将所有通道的点数累加起来，得到总的点数。
      // `std::accumulate` 函数从给定范围的起始位置（`points_per_channel.begin()`）到结束位置（`points_per_channel.end()`），以初始值0为基础，
      // 依次将每个元素累加到这个初始值上，最终得到总和，并将结果转换为 `uint32_t` 类型存储在 `total_points` 变量中。
      uint32_t total_points = static_cast<uint32_t>(
          std::accumulate(points_per_channel.begin(), points_per_channel.end(), 0));
      // 清空存储检测点数据的 `_ser_points` 向量，释放之前占用的内存空间，以便后续重新填充新的检测点数据。
      _ser_points.clear();
      // 为存储检测点数据的 `_ser_points` 向量重新预留足够的内存空间，根据计算出的总点数 `total_points` 来确定需要的内存大小，
      // 这样在后续添加检测点数据时可以减少内存分配的次数，提高效率，避免频繁的内存重新分配操作带来的性能损耗。
      _ser_points.reserve(total_points);
    }
    // 虚函数，用于将每个通道的点数信息写入到内部的 `_header` 向量中，以更新对象中存储的每个通道实际包含的点数情况。
    // 通常在获取到新的一轮激光雷达各通道点数数据后调用，用于更新内部记录，方便后续其他操作基于准确的通道点数信息进行。
    virtual void WriteChannelCount(std::vector<uint32_t> points_per_channel) {
      // 循环遍历每个通道索引，从0开始，直到达到当前对象记录的通道数量（通过 `GetChannelCount()` 获取）。
      for (auto idxChannel = 0u; idxChannel < GetChannelCount(); ++idxChannel)
        // 将对应通道的点数设置到 `_header` 向量的相应位置，即 `Index::SIZE + idxChannel` 索引处，
        // 用传入的 `points_per_channel` 向量中对应索引位置的元素值进行更新，确保 `_header` 中存储的通道点数信息与实际情况相符。
        _header[Index::SIZE + idxChannel] = points_per_channel[idxChannel];
    }
    // 虚函数，用于将一个 `SemanticLidarDetection` 类型的检测点数据同步写入到内部存储检测点数据的 `_ser_points` 向量中。
    // 这个函数常用于在接收到新的激光雷达检测点数据时，逐个将这些数据添加到对象中进行统一管理，方便后续对所有检测点数据进行序列化、分析等操作。
    virtual void WritePointSync(SemanticLidarDetection &detection) {
      _ser_points.emplace_back(detection);
    }

  protected:
  // 存储激光雷达数据头部信息的向量，其中包含了水平角度、通道数量以及每个通道的点数等相关信息，以 `uint32_t` 类型的数据进行存储。
  // 通过这种方式可以方便地进行内存操作（如拷贝、清零等）以及按照特定索引访问不同的数据元素，为整个激光雷达数据的管理提供了基础的数据结构支持。
    std::vector<uint32_t> _header;
  // 用于记录最大通道点数的变量，虽然在当前代码中没有明显看到其具体的使用场景，但可能在后续的一些逻辑中用于判断数据是否超出某个范围、
  // 进行内存优化或者与其他相关限制条件进行比较等情况，具体用途取决于该类在整个项目中的完整功能实现和使用方式。
    uint32_t _max_channel_points;

  private:
    // 存储所有检测点数据的向量，每个元素都是一个 `SemanticLidarDetection` 类型的对象，用于保存激光雷达实际检测到的各个点的详细信息，
    // 包括点的位置（通过 `SemanticLidarDetection` 类中的 `point` 成员表示）、检测光线与被击中物体法线之间夹角的余弦值（`cos_inc_angle` 成员）、
    // 被检测物体的索引（`object_idx` 成员）以及被检测物体的语义标签（`object_tag` 成员）等。通过这个向量可以集中管理和操作所有的检测点数据。
    std::vector<SemanticLidarDetection> _ser_points;
    // 将 `s11n::SemanticLidarHeaderView`、`s11n::SemanticLidarSerializer` 和 `carla::ros2::ROS2` 这三个类声明为友元类。
    // 友元类的作用是可以访问 `SemanticLidarData` 类的私有成员和受保护成员，这样做的目的通常是为了方便在这些相关类中实现特定功能时，
    // 能够直接操作 `SemanticLidarData` 类内部的数据结构，而不受访问控制的限制，例如在序列化、头视图展示以及和 ROS2 相关的功能实现过程中可能需要直接访问其私有或受保护成员变量和函数。
  friend class s11n::SemanticLidarHeaderView;
  friend class s11n::SemanticLidarSerializer;
  friend class carla::ros2::ROS2;

  };

} // namespace s11n
} // namespace sensor
} // namespace carla
