// Copyright (c) 2017 Computer Vision Center (CVC) at the Universitat Autonoma
// de Barcelona (UAB).
//
// This work is licensed under the terms of the MIT license.
// For a copy, see <https://opensource.org/licenses/MIT>.

#pragma once

#include "carla/rpc/Location.h"
#include "carla/sensor/data/SemanticLidarData.h"

#include <cstdint>
#include <vector>

namespace carla {

namespace ros2 {
  class ROS2;
}

namespace sensor {

namespace s11n {
  class LidarSerializer;
  class LidarHeaderView;
}

namespace data {

  /// Helper class to store and serialize the data generated by a Lidar.
  /// 辅助类，用于存储和序列化激光雷达生成的数据。
  ///
  /// The header of a Lidar measurement consists of an array of uint32_t's in
  /// the following layout
  /// 激光雷达测量的头部由一个uint32_t数组构成，其布局如下：
  ///
  ///    {
  ///      Horizontal angle (float),
  /// 水平角度（float）
  ///      Channel count,
  /// 通道数，
  ///      Point count of channel 0,
  /// 通道0的点数，
  ///      ...
  ///      Point count of channel n,
  /// 通道n的点数，
  ///    }
  ///
  /// The points are stored in an array of floats

/// 点数据存储在一个float数组中，格式如下：
  ///
  ///    {
  ///      X0, Y0, Z0, I0
  /// X0, Y0, Z0, I0 （第一个点的x, y, z坐标和强度）
  ///      ...
  ///      Xn, Yn, Zn, In

  /// Xn, Yn, Zn, In （第n个点的x, y, z坐标和强度）
  ///    }
  ///
// LidarDetection类用于存储单个激光雷达检测点的数据
class LidarDetection {
public:
  // 点的地理位置，使用carla::geom::Location表示
  geom::Location point;
  // 点的强度信息
  float intensity;

  // 默认构造函数，初始化点为(0,0,0)，强度为0
  LidarDetection() : point(0.0f, 0.0f, 0.0f), intensity(0.0f) {}
  // 构造函数，根据提供的坐标和强度初始化
  LidarDetection(float x, float y, float z, float intensity) : point(x, y, z), intensity(intensity) {}
  // 构造函数，根据提供的geom::Location和强度初始化
  LidarDetection(geom::Location p, float intensity) : point(p), intensity(intensity) {}

  // 向输出流写入PLY文件头信息
  void WritePlyHeaderInfo(std::ostream& out) const {
    out << "property float32 x\n"
        << "property float32 y\n"
        << "property float32 z\n"
        << "property float32 I";
  }

      void WriteDetection(std::ostream& out) const{
      // 写入检测点的x, y, z坐标和强度，以空格分隔
        out << point.x << ' ' << point.y << ' ' << point.z << ' ' << intensity;
      }
  };

  // LidarData类继承自SemanticLidarData，用于存储和序列化激光雷达生成的数据
class LidarData : public SemanticLidarData {

public:
  // 构造函数，接受一个可选的通道数参数，默认值为0
  explicit LidarData(uint32_t ChannelCount = 0u)
    : SemanticLidarData(ChannelCount) {
  }

  // 移动赋值运算符，使用默认实现
  LidarData &operator=(LidarData &&) = default;

  // 析构函数，使用默认实现
  ~LidarData() = default;

  // 重置内存的方法，接受一个包含每个通道点数的向量
  // 根据提供的点数重新分配和初始化内部存储
  virtual void ResetMemory(std::vector<uint32_t> points_per_channel) {
    // 断言确保通道数大于points_per_channel的大小（这里可能是逻辑上的错误，通常应检查points_per_channel的大小不超过通道数）
    DEBUG_ASSERT(GetChannelCount() > points_per_channel.size());

    // 使用memset将_header中特定位置后的内存清零，准备存储新的数据
    // 假设_header是一个包含头部信息的std::vector<uint32_t>，Index::SIZE是头部固定部分的大小
    std::memset(_header.data() + Index::SIZE, 0, sizeof(uint32_t) * GetChannelCount());


    // 计算所有通道的总点数，并据此重置_points的大小和预留空间
    uint32_t total_points = static_cast<uint32_t>(
        std::accumulate(points_per_channel.begin(), points_per_channel.end(), 0));

    _points.clear(); // 清空_points
    _points.reserve(total_points * 4); // 预留足够的空间，每个点包含x, y, z, intensity四个float值
  }

  // 将一个LidarDetection对象的数据同步写入到内部存储中
  void WritePointSync(LidarDetection &detection) {
    // 将检测点的x, y, z坐标和强度依次添加到_points向量中
    _points.emplace_back(detection.point.x);
    _points.emplace_back(detection.point.y);
    _points.emplace_back(detection.point.z);
    _points.emplace_back(detection.intensity);
  }


  // 一个重载的WritePointSync方法，用于SemanticLidarDetection对象
  // 但在这个实现中，它仅断言失败，表明这个方法不应该被调用
  // 这可能是因为SemanticLidarDetection和LidarDetection有不同的数据格式
  virtual void WritePointSync(SemanticLidarDetection &detection) {
    (void) detection; // 避免未使用变量的警告
    DEBUG_ASSERT(false); // 断言失败，表明这个方法不应该被调用
  }

private:
  // 存储点的数据，每个点包含x, y, z, intensity四个float值
  std::vector<float> _points;

  // 友元类，允许它们访问私有成员_points和_header
  friend class s11n::LidarSerializer;
  friend class s11n::LidarHeaderView;
  friend class carla::ros2::ROS2;
};
