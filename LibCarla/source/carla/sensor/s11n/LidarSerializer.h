// Copyright (c) 2019 Computer Vision Center (CVC) at the Universitat Autonoma
// de Barcelona (UAB).
//
// This work is licensed under the terms of the MIT license.
// For a copy, see <https://opensource.org/licenses/MIT>.

#pragma once
// 预处理指令，确保该头文件在整个编译过程中只会被包含一次

#include "carla/Debug.h" // 引入carla项目中的Debug.h头文件
#include "carla/Memory.h" // 引入carla项目中的Memory.h头文件
#include "carla/sensor/RawData.h" // 引入carla项目中sensor模块下的RawData.h头文件
#include "carla/sensor/data/LidarData.h" // 引入carla项目中sensor模块下data子模块中的LidarData.h头文件

namespace carla {
namespace sensor {

  class SensorData;
 // 前置声明SensorData类

namespace s11n {

  // ===========================================================================
  // -- LidarHeaderView --------------------------------------------------------
  // ===========================================================================

  /// A view over the header of a Lidar measurement.
  class LidarHeaderView {
    using Index = data::LidarData::Index;
// 使用using关键字为data::LidarData::Index类型定义一个别名Index，方便后续代码中使用这个类型来表示相关的索引，使得代码更简洁易读

  public:
    float GetHorizontalAngle() const {
// 定义一个常成员函数GetHorizontalAngle，用于获取激光雷达数据头部中的水平角度信息，返回值为float类型，表示角度大小
      return reinterpret_cast<const float &>(_begin[Index::HorizontalAngle]);
// 通过reinterpret_cast进行强制类型转换，将存储在_begin数组中按照Index::HorizontalAngle索引位置处的数据转换为const float类型的引用并返回，也就是获取水平角度的值
    }

    uint32_t GetChannelCount() const {
// 定义一个常成员函数GetChannelCount，用于获取激光雷达数据头部中的通道数量信息，返回值为无符号32位整数类型（uint32_t）
      return _begin[Index::ChannelCount];
 // 从_begin数组中按照Index::ChannelCount索引位置获取对应的值，这个值代表了激光雷达数据的通道数量，同样假设_begin数组按规则存储了相关信息
    }

    uint32_t GetPointCount(size_t channel) const {
 // 定义一个常成员函数GetPointCount，用于获取指定通道（参数channel表示通道编号）下的点数量信息，返回值为无符号32位整数类型（uint32_t）

      DEBUG_ASSERT(channel < GetChannelCount());
 // 使用DEBUG_ASSERT宏进行断言检查，确保传入的通道编号channel小于通过GetChannelCount函数获取到的总通道数量，即保证通道编号是合法有效的

      return _begin[Index::SIZE + channel];
 // 从_begin数组中按照Index::SIZE + channel这个索引位置获取对应的值
    }

  private:
    friend class LidarSerializer;
 // 将LidarSerializer类声明为友元类，，意味着LidarSerializer类可以访问LidarHeaderView类的私有成员变量和私有成员函数，方便两者之间进行协作，通常在有紧密关联的数据操作时会这样设计

    explicit LidarHeaderView(const uint32_t *begin) : _begin(begin) {
 // 定义私有构造函数，使用explicit关键字防止隐式类型转换，它接受一个指向无符号32位整数（uint32_t）的指针begin作为参数，用于初始化成员变量

      DEBUG_ASSERT(_begin != nullptr);
// 使用DEBUG_ASSERT宏进行断言检查，确保传入的指针_begin不为空指针，保证后续通过该指针访问数据的操作是安全的
    }

    const uint32_t *_begin;
// 定义一个私有成员变量_begin，它是一个指向无符号32位整数（uint32_t）的指针，用于指向存储激光雷达数据头部信息的内存区域，通过这个指针结合相应的索引来访问头部中的各个数据成员
  };

  // ===========================================================================
  // -- LidarSerializer --------------------------------------------------------
  // ===========================================================================

  /// Serializes the data generated by Lidar sensors.
  class LidarSerializer {
  public:

    static LidarHeaderView DeserializeHeader(const RawData &data) {
 // 定义一个静态成员函数DeserializeHeader，用于从给定的RawData类型的对象（传感器原始数据）中反序列化出激光雷达数据的头部视图（LidarHeaderView类型）

      return LidarHeaderView{reinterpret_cast<const uint32_t *>(data.begin())};
 // 通过reinterpret_cast进行强制类型转换，将传感器原始数据（data）的起始地址（data.begin()）转换为指向无符号32位整数（const uint32_t *）的指针，然后以此为参数构造一个LidarHeaderView对象并返回，也就是从原始数据中提取出头部信息对应的视图
    }

    static size_t GetHeaderOffset(const RawData &data) {
 // 定义一个静态成员函数GetHeaderOffset，用于获取激光雷达数据头部在整个原始数据中的偏移量
      auto View = DeserializeHeader(data);
// 首先调用DeserializeHeader函数从给定的原始数据（data）中获取激光雷达数据的头部视图（LidarHeaderView类型），并将结果保存在View变量中
      return sizeof(uint32_t) * (View.GetChannelCount() + data::LidarData::Index::SIZE);
 // 根据获取到的头部视图View中的通道数量（通过View.GetChannelCount()获取）以及data::LidarData::Index::SIZE，计算出头部的偏移量
    }

    template <typename Sensor>
    static Buffer Serialize(
        const Sensor &sensor,
        const data::LidarData &data,
        Buffer &&output);
// 定义一个函数模板Serialize，用于将激光雷达数据进行序列化并存储到给定的Buffer类型的对象中（参数output），这个函数模板可以适用于不同类型的Sensor

    static SharedPtr<SensorData> Deserialize(RawData &&data);
 // 定义一个静态成员函数Deserialize，用于从右值引用类型的RawData对象（传感器原始数据）中反序列化出一个指向SensorData类的智能指针（SharedPtr<SensorData>），这里使用右值引用可以更高效地处理临时对象等情况
  };

  // ===========================================================================
  // -- LidarSerializer implementation -----------------------------------------
  // ===========================================================================

  template <typename Sensor>
  inline Buffer LidarSerializer::Serialize(
      const Sensor &,
      const data::LidarData &data,
      Buffer &&output) {
 // 这是LidarSerializer类中Serialize函数模板的具体实现部分，用于对给定的激光雷达数据（data::LidarData类型的data）进行序列化并存储到可移动的Buffer对象（output）中，适用于特定类型的Sensor（由模板参数决定）

    std::array<boost::asio::const_buffer, 2u> seq = {
        boost::asio::buffer(data._header),
        boost::asio::buffer(data._points)};
// 创建一个包含两个boost::asio::const_buffer类型元素的数组seq，通过调用boost::asio::buffer函数，分别将激光雷达数据中的头部信息（data._header）和点数据（data._points）转换为const_buffer类型，以便后续进行数据复制等操作，这里假设data._header和data._points是激光雷达数据中不同部分的数据成员，并且boost::asio相关的函数用于处理数据缓冲区相关的操作
    output.copy_from(seq);
// 调用output对象（Buffer类型，应该实现了copy_from之类的函数用于接收数据）的copy_from函数，将数组seq中的数据（即激光雷达数据的头部和点数据）复制到output所代表的缓冲区中，完成序列化后数据的存储
    return std::move(output);
// 通过std::move将output对象转换为右值引用返回
  }

} // namespace s11n
} // namespace sensor
} // namespace carla
