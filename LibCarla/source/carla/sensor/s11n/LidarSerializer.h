// Copyright (c) 2019 Computer Vision Center (CVC) at the Universitat Autonoma
// de Barcelona (UAB).
//
// This work is licensed under the terms of the MIT license.
// For a copy, see <https://opensource.org/licenses/MIT>.
// 预处理指令，确保头文件只被包含一次，避免重复定义问题
#pragma once
// 包含CARLA相关的调试辅助头文件，可能包含一些用于断言、日志输出等调试相关的宏或函数定义
#include "carla/Debug.h" // 包含CARLA相关的内存管理头文件，比如可能涉及智能指针等内存相关工具类或函数的定义
#include "carla/Memory.h" // 包含传感器原始数据相关的头文件，用于表示传感器获取到的最基础、未经处理的数据结构等定义
#include "carla/sensor/RawData.h" // 包含激光雷达数据相关的头文件，其中应该定义了激光雷达数据特有的数据结构、成员等信息
#include "carla/sensor/data/LidarData.h"
// 定义在carla命名空间下的sensor命名空间中，这是一个组织代码逻辑、避免命名冲突的作用域
namespace carla {
namespace sensor {
// 前置声明SensorData类，告诉编译器有这个类存在，但具体定义在其他地方提供，方便后续代码中可以使用该类的指针等
  class SensorData;

namespace s11n {

  // ===========================================================================
  // -- LidarHeaderView --------------------------------------------------------
  // ===========================================================================// 以下是对这个部分的注释，这是一个用于查看激光雷达测量数据头部信息的类定义

  /// A view over the header of a Lidar measurement.
  class LidarHeaderView { // 使用using关键字定义一个类型别名Index，它等同于data::LidarData::Index类型，方便后续代码书写和理解
    using Index = data::LidarData::Index;

  public: // 获取激光雷达水平角度信息的函数，返回一个float类型的角度值
    // 通过对存储数据的内存进行重新解释（reinterpret_cast）来获取对应位置的float值，假设数据存储格式符合要求
    float GetHorizontalAngle() const {
      return reinterpret_cast<const float &>(_begin[Index::HorizontalAngle]);
    }
// 获取激光雷达通道数量的函数，返回一个uint32_t类型的通道数量值
    // 直接从存储数据的内存位置（_begin数组）中获取对应索引（Index::ChannelCount）处的值
    uint32_t GetChannelCount() const {
      return _begin[Index::ChannelCount];
    }
// 获取指定通道上的点数量的函数，参数channel指定要查询的通道索引
    // 首先会进行断言（DEBUG_ASSERT）确保传入的通道索引小于总的通道数量（通过GetChannelCount函数获取）
    // 然后从存储数据的内存位置（_begin数组）中获取对应偏移位置（Index::SIZE + channel）处的值作为点数量返回
    uint32_t GetPointCount(size_t channel) const {
      DEBUG_ASSERT(channel < GetChannelCount());
      return _begin[Index::SIZE + channel];
    }

  private: // 将LidarSerializer类声明为友元类，意味着LidarSerializer类可以访问LidarHeaderView类的私有成员
    friend class LidarSerializer;
// 构造函数，接受一个指向uint32_t类型的指针begin，用于初始化内部存储数据起始位置的成员变量_begin
    // 同时进行断言（DEBUG_ASSERT）确保传入的指针不为空，保证后续操作的合法性
    explicit LidarHeaderView(const uint32_t *begin) : _begin(begin) {
      DEBUG_ASSERT(_begin != nullptr);
    }
// 存储指向激光雷达数据头部信息存储区域的起始指针，通过这个指针来访问头部相关的数据成员
    const uint32_t *_begin;
  };

  // ===========================================================================
  // -- LidarSerializer --------------------------------------------------------
  // ===========================================================================

  /// Serializes the data generated by Lidar sensors.
  class LidarSerializer {
  public:
// 静态函数，用于从给定的原始数据（RawData类型）中反序列化出激光雷达数据的头部视图（LidarHeaderView类型）
    // 通过将原始数据的起始位置（data.begin()）重新解释为指向uint32_t类型的指针来构造LidarHeaderView对象并返回
    static LidarHeaderView DeserializeHeader(const RawData &data) {
      return LidarHeaderView{reinterpret_cast<const uint32_t *>(data.begin())};
    }
// 静态函数，用于获取激光雷达数据头部在整个原始数据中的偏移量（以字节为单位）
    // 首先通过DeserializeHeader函数获取头部视图，然后根据头部视图中的通道数量以及固定的索引偏移量等信息
    // 计算出头部在整个原始数据中的字节偏移量，返回一个size_t类型的偏移量值
    static size_t GetHeaderOffset(const RawData &data) {
      auto View = DeserializeHeader(data);
      return sizeof(uint32_t) * (View.GetChannelCount() + data::LidarData::Index::SIZE);
    }
// 模板函数，用于将激光雷达数据（data::LidarData类型）按照特定传感器（Sensor类型）的要求进行序列化
    // 参数sensor表示具体的传感器对象，data表示要序列化的激光雷达数据，output表示输出的缓冲区（Buffer类型）
    // 返回序列化后的缓冲区，这里使用了右值引用（Buffer &&output）来避免不必要的拷贝，提高效率
    template <typename Sensor>
    static Buffer Serialize(
        const Sensor &sensor,
        const data::LidarData &data,
        Buffer &&output);
// 静态函数，用于从给定的原始数据（RawData类型，这里使用右值引用，可能涉及到数据所有权转移等优化）中反序列化出传感器数据（SensorData类型）
    // 返回一个智能指针（SharedPtr<SensorData>）指向反序列化后的传感器数据对象，方便内存管理和对象生命周期控制
    static SharedPtr<SensorData> Deserialize(RawData &&data);
  };

  // ===========================================================================
  // -- LidarSerializer implementation -----------------------------------------
  // ===========================================================================

  template <typename Sensor>
  inline Buffer LidarSerializer::Serialize(
      const Sensor &,
      const data::LidarData &data,
      Buffer &&output) { // 创建一个包含两个元素的数组seq，每个元素是一个boost::asio::const_buffer类型，用于表示要复制的数据缓冲区
    // 第一个缓冲区指向激光雷达数据的头部（data._header），第二个缓冲区指向激光雷达数据的点数据部分（data._points）
    std::array<boost::asio::const_buffer, 2u> seq = {
        boost::asio::buffer(data._header),
        boost::asio::buffer(data._points)}; // 使用output缓冲区的copy_from方法，将上述定义的两个缓冲区的数据复制到output缓冲区中，完成序列化操作
    output.copy_from(seq); // 返回移动后的output缓冲区，这里移动语义可以避免深拷贝，提高性能，将序列化后的数据所在的缓冲区返回
    return std::move(output);
  }

} // namespace s11n
} // namespace sensor
} // namespace carla
