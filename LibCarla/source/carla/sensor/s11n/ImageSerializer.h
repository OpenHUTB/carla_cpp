// Copyright (c) 2017 Computer Vision Center (CVC) at the Universitat Autonoma
// de Barcelona (UAB).
//
// This work is licensed under the terms of the MIT license.
// For a copy, see <https://opensource.org/licenses/MIT>.

#pragma once
// 预处理指令，用于确保该头文件在整个项目的编译过程中只会被包含一次

#include "carla/Memory.h"
// 引入carla项目中与内存管理相关的头文件
#include "carla/sensor/RawData.h"
// 引入carla项目里有关传感器原始数据（RawData）的头文件

#include <cstdint>
// 引入C++标准库中用于定义固定宽度整数类型的头文件
#include <cstring>
// 引入C++标准库中包含字符串处理以及内存操作相关函数（比如memcpy等函数）的头文件，后续代码中可以利用这些函数来进行内存中数据的拷贝等操作。

namespace carla {
namespace sensor {

  class SensorData;
// 前向声明SensorData类
namespace s11n {

  /// Serializes image buffers generated by camera sensors.
  class ImageSerializer {
  public:

#pragma pack(push, 1)
// 这是一个预处理指令，用于设置结构体的字节对齐方式为1字节对齐

    struct ImageHeader {
      uint32_t width;
// 定义一个32位无符号整数类型的成员变量
      uint32_t height;
 // 同样是32位无符号整数类型的成员变量
      float fov_angle;
 // 定义一个单精度浮点数类型的成员变量
    };
#pragma pack(pop)
// 恢复之前的默认字节对齐方式，取消掉由#pragma pack(push, 1)所设置的紧凑对齐状态

    constexpr static auto header_offset = sizeof(ImageHeader);
 // 使用constexpr关键字定义一个静态常量，将其初始化为ImageHeader结构体的大小（字节数）。

    static const ImageHeader &DeserializeHeader(const RawData &data) {
      return *reinterpret_cast<const ImageHeader *>(data.begin());
// 定义一个静态函数DeserializeHeader，它的功能是对传入的原始数据（类型为RawData）进行反序列化操作，目的是获取其中的图像头部信息。
// 具体实现方式是，先获取原始数据的起始地址（通过data.begin()获取），然后使用reinterpret_cast操作符将这个起始地址强制转换为指向ImageHeader结构体的指针类型
 // 最后返回这个指针所指向的ImageHeader结构体的引用，这样就能够获取到解析出来的头部信息结构体，进而可以方便地使用其中各个成员变量进行后续相应的处理操作。
    }

    template <typename Sensor>
    static Buffer Serialize(const Sensor &sensor, Buffer &&bitmap);
 // 定义一个静态模板函数Serialize，它用于将特定传感器（由模板参数Sensor来指定具体类型）相关的图像缓冲区数据（由参数bitmap表示）进行序列化操作。
// 参数sensor是对应传感器的对象引用，通过它可以获取到传感器相关的图像属性等信息；bitmap是要进行序列化的图像缓冲区

    static SharedPtr<SensorData> Deserialize(RawData &&data);
// 定义一个静态函数Deserialize，该函数用于将传入的原始数据（通过右值引用的方式接收，即RawData &&data，这样做可以避免不必要的拷贝操作）进行反序列化处理。
// 最终函数会返回一个指向SensorData类型的共享智能指针（SharedPtr表示共享所有权的智能指针，使用它有助于进行内存管理以及控制对象的生命周期）
// 也就是把原始数据还原为相应的传感器数据对象形式，方便后续在程序中进一步使用该数据。

  };

  template <typename Sensor>
  inline Buffer ImageSerializer::Serialize(const Sensor &sensor, Buffer &&bitmap) {
    DEBUG_ASSERT(bitmap.size() > sizeof(ImageHeader));
 // 使用DEBUG_ASSERT宏进行断言检查
// 其目的是确保传入的图像缓冲区（bitmap）的大小要大于ImageHeader结构体的大小。因为后续操作需要在缓冲区前面添加头部信息，如果缓冲区大小不够就会出现问题

    ImageHeader header = {
      sensor.GetImageWidth(),
      sensor.GetImageHeight(),
      sensor.GetFOVAngle()
    };
// 创建一个ImageHeader结构体的对象header
// 然后使用这些获取到的值对header结构体进行初始化赋值，为后续将这些信息添加到图像缓冲区作为头部信息做好准备。

    std::memcpy(bitmap.data(), reinterpret_cast<const void *>(&header), sizeof(header));
// 使用来自<cstring>头文件中的std::memcpy函数，将刚才创建并初始化好的header结构体的数据复制到图像缓冲区（bitmap）的起始位置。
// 这里需要先将header结构体的指针通过reinterpret_cast转换为void*类型，以满足std::memcpy函数对于参数类型的要求，并且指定复制的数据字节数为header结构体的大小（sizeof(header)）

    return std::move(bitmap);
// 通过移动语义（使用std::move函数）返回填充好头部信息的图像缓冲区（bitmap）。采用移动语义的好处是避免了不必要的数据拷贝操作，提高了函数返回的效率
  }

} // namespace s11n
} // namespace sensor
} // namespace carla
