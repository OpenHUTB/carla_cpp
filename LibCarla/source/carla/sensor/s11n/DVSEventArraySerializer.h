// Copyright (c) 2020 Robotics and Perception Group (GPR)
// University of Zurich and ETH Zurich
//
// This work is licensed under the terms of the MIT license.
// For a copy, see <https://opensource.org/licenses/MIT>.
// 版权声明部分，表明这段代码的版权归属（2020年属于苏黎世大学和苏黎世联邦理工学院的机器人与感知小组），同时说明代码遵循MIT许可证开源协议，并给出了该许可证的查看链接。
#pragma once // 预处理指令，用于确保头文件在编译时只被包含一次，避免重复定义类、结构体等造成的编译错误，提高编译效率。

#include "carla/Memory.h"
#include "carla/sensor/RawData.h"
#include "carla/sensor/data/DVSEvent.h"
// 引入了三个自定义的头文件，分别来自 "carla" 相关的模块。
// "carla/Memory.h" 可能包含了内存管理相关的定义，例如智能指针、内存分配等功能的实现或者相关类型声明，用于在代码中合理地管理对象生命周期以及内存资源。
// "carla/sensor/RawData.h" 推测是定义了传感器原始数据相关的结构体或者类，包含了传感器获取到的最基本的数据表示形式以及相关操作函数等内容。
// "carla/sensor/data/DVSEvent.h" 应该是针对特定的动态视觉传感器（DVS）事件相关的数据结构、类型定义等，用于处理 DVS 相机传感器产生的事件数据。
#include <cstdint>
#include <cstring>
// 引入C++标准库中的 <cstdint> 和 <cstring> 头文件。
// <cstdint> 头文件提供了固定宽度的整数类型定义，如 uint32_t（无符号32位整数）等，方便在跨平台编程时确保整数类型的大小一致性，适用于对内存布局、数据传输格式等有严格要求的场景。
// <cstring> 头文件提供了一些字符串处理相关的函数，如 memcpy（内存复制函数）等，常用于对内存数据进行拷贝操作，在本代码中用于数据的序列化和反序列化时复制数据。
namespace carla {
namespace sensor {
// 定义了 carla::sensor 命名空间，用于组织和封装与传感器相关的代码逻辑，将下面定义的所有类型、函数等都放在这个命名空间下，避免与其他模块中的同名实体发生命名冲突。
  class SensorData;
// 前置声明 SensorData 类，告知编译器后续会定义这个类，这样在当前代码位置可以使用该类的指针或引用等，解决编译时因还未看到完整类定义而可能出现的报错问题，通常其完整定义会在其他相关源文件或者头文件中给出。
namespace s11n {
// 在 carla::sensor 命名空间下进一步定义 s11n 子命名空间，可能用于表示序列化（serialization）和反序列化（deserialization）相关的功能代码，将相关的类型和函数放在这里进行统一管理。
  /// Serializes events array generated by DVS camera sensors.
  class DVSEventArraySerializer { // 定义了一个名为 DVSEventArraySerializer 的类，从类的注释可以看出，它的主要作用是对由 DVS 相机传感器生成的事件数组进行序列化操作，即将相关数据按照特定格式转换为可存储或传输的形式。
  public:
// 以下是类的公有成员部分，外部代码可以通过类的对象直接访问这些成员。
#pragma pack(push, 1)
    struct DVSHeader {
      uint32_t width;
      uint32_t height;
      float fov_angle;
    };
#pragma pack(pop)
//使用 #pragma pack 指令来控制结构体的内存对齐方式。
    // #pragma pack(push, 1) 表示将当前的对齐方式压入堆栈，并设置新的对齐方式为1字节对齐，这样定义的结构体 DVSHeader 中的成员会紧密排列，没有额外的填充字节，便于按照精确的字节数进行数据处理（例如序列化和反序列化时）。
    // 结构体 DVSHeader 定义了三个成员，分别用于表示 DVS 相机传感器图像的宽度（width，无符号32位整数类型）、高度（height，无符号32位整数类型）以及视场角（fov_angle，单精度浮点数类型），这些信息通常是描述传感器数据的基本属性，会在序列化和反序列化过程中用到。
    // #pragma pack(pop) 则是恢复之前压入堆栈的对齐方式，保证后续代码的内存对齐按照原有的设置进行。
    constexpr static auto header_offset = sizeof(DVSHeader); // 使用 constexpr 关键字定义了一个编译期常量 header_offset，其值等于 DVSHeader 结构体的大小（通过 sizeof 运算符获取），用于在后续代码中表示头部数据在整个序列化数据中的偏移量，方便定位和处理后续的数据部分。
    using DVSEventArray = std::vector<data::DVSEvent>;
// 为 std::vector<data::DVSEvent> 类型定义了一个别名 DVSEventArray，这样在代码中使用该类型时可以用更简洁的别名来表示，提高代码的可读性，该类型表示一个由 DVS 相机传感器事件（data::DVSEvent 类型）组成的动态数组，用于存储和操作相关的事件数据。
    static const DVSHeader &DeserializeHeader(const RawData &data) {
      return *reinterpret_cast<const DVSHeader *>(data.begin());
    }
// 定义了一个静态成员函数 DeserializeHeader，用于从给定的 RawData 类型的对象中反序列化出 DVSHeader 结构体数据。
    // 通过 reinterpret_cast 将指向 RawData 起始位置的指针（data.begin()）转换为指向 DVSHeader 结构体的指针，然后解引用返回该结构体的引用，实现了从原始数据中提取头部信息的功能。注意这种转换要求数据的内存布局要符合预期，否则可能导致错误。
    template <typename Sensor>
    static Buffer Serialize(const Sensor &sensor, const DVSEventArray &events, Buffer &&output);
// 定义了一个模板静态成员函数 Serialize，用于将传感器数据和对应的事件数组进行序列化操作。
    // 它是一个模板函数，接受一个传感器类型（Sensor）的对象引用、一个 DVSEventArray 类型的事件数组引用以及一个右值引用形式的 Buffer 类型对象（用于存储序列化后的数据，可能是自定义的某种缓冲区类型，其完整定义应该在 "carla/Memory.h" 等相关头文件中），返回序列化后的 Buffer 对象（通过 std::move 进行资源所有权转移，避免不必要的拷贝），具体的序列化逻辑会根据传入的不同传感器类型（由模板参数决定）和事件数据来实现。
    static SharedPtr<SensorData> Deserialize(RawData &&data); // 定义了一个静态成员函数 Deserialize，用于对给定的原始数据（RawData 类型，通过右值引用接收，可能是为了提高效率，避免不必要的拷贝，特别是对于临时对象）进行反序列化操作，将其转换为一个指向 SensorData 类型对象的智能指针（SharedPtr，通常用于自动管理对象的生命周期，避免内存泄漏等问题，其定义应该在 "carla/Memory.h" 等相关头文件中），返回的智能指针指向反序列化后构建的 SensorData 对象，如果反序列化失败可能返回空指针等表示异常情况。
  };

  template <typename Sensor>
  inline Buffer DVSEventArraySerializer::Serialize(const Sensor &sensor, const DVSEventArray &events, Buffer &&output) { // 这是对前面声明的模板函数 Serialize 的具体实现，定义在类的外部，实现了将传感器数据和事件数组序列化到给定缓冲区的功能。
    DEBUG_ASSERT(events.size() > sizeof(DVSHeader)); // 使用 DEBUG_ASSERT 宏（推测是自定义的用于调试的断言宏，可能在特定的调试模式下会检查这个条件是否满足，如果不满足则触发调试中断或者输出错误信息等）来确保传入的事件数组大小大于 DVSHeader 结构体的大小，因为要序列化的数据除了头部信息外，至少还得包含一些事件数据才有意义，否则可能表示数据出现异常情况。
    DVSHeader header = {
      sensor.GetImageWidth(),
      sensor.GetImageHeight(),
      sensor.GetFOVAngle(),
    };
// 创建一个 DVSHeader 结构体对象 header，并通过调用传感器对象（sensor）的相关成员函数（GetImageWidth、GetImageHeight、GetFOVAngle，这些函数应该是在传感器类中定义的用于获取图像宽度、高度和视场角的接口）来初始化其成员，用于构建要序列化的头部信息。
    /// Reset the output buffer
    output.reset(sizeof(DVSHeader) + (events.size() * sizeof(data::DVSEvent)));
// 调用缓冲区对象（output）的 reset 函数（具体功能由其所属类型的定义决定，可能是重新分配内存、设置缓冲区大小等操作），将缓冲区大小设置为刚好能容纳头部信息（DVSHeader 结构体大小）加上所有事件数据（每个事件数据大小为 sizeof(data::DVSEvent)，乘以事件数组的大小 events.size()）的空间，为后续数据拷贝做准备。
    /// Pointer to data in buffer
    unsigned char *it = output.data();
// 获取缓冲区对象（output）中指向数据存储位置的指针（通过 data 函数获取，同样其具体实现由缓冲区类型定义决定），并赋值给指针变量 it，后续将通过这个指针来操作缓冲区中的数据，进行数据的拷贝等操作。
    /// Copy the header into the output buffer
    std::memcpy(it, reinterpret_cast<const void *>(&header), sizeof(header));
    it += sizeof(DVSHeader);
// 使用 std::memcpy 函数将前面构建好的头部信息（header 结构体）复制到缓冲区中，从指针 it 指向的位置开始复制，复制的字节数为 header 结构体的大小（sizeof(header)）。
    // 然后将指针 it 向后移动 sizeof(DVSHeader) 个字节，使其指向缓冲区中用于存储后续事件数据的起始位置，为下一步复制事件数据做准备。
    /// Copy the events into the output buffer
    for (auto e : events) {
      std::memcpy(it, reinterpret_cast<const void *>(&e), sizeof(data::DVSEvent));
      it += sizeof(data::DVSEvent);
    } // 通过循环遍历事件数组 events，对于每个事件元素 e，使用 std::memcpy 函数将其复制到缓冲区中，从当前指针 it 指向的位置开始复制，复制的字节数为每个事件数据的大小（sizeof(data::DVSEvent)），然后将指针 it 再向后移动 sizeof(data::DVSEvent) 个字节，以便下一次复制事件数据，这样依次将所有事件数据都复制到缓冲区中。
    return std::move(output); // 通过 std::move 将缓冲区对象 output 以右值引用的形式返回，实现了资源所有权的转移，避免了可能的深拷贝操作，提高了效率，返回的缓冲区就是序列化后包含头部信息和所有事件数据的结果。
  }

} // namespace s11n
} // namespace sensor
} // namespace carla
